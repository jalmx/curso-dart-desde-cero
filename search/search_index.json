{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Curso de Dart desde Cero","text":"<p>Curso de Dart desde cero</p>"},{"location":"#contenido","title":"Contenido","text":"<ol> <li>Configuraci\u00f3n del Entorno de Desarrollo<ol> <li>Instalaci\u00f3n de Dart SDK.</li> <li>Configuraci\u00f3n del entorno de desarrollo (IDE).</li> </ol> </li> <li>Sintaxis B\u00e1sica de Dart<ol> <li>Variables y tipos de datos.</li> <li>Estructuras de control: if, if-else.</li> <li>Bucles: for, while.</li> </ol> </li> <li>Colecciones<ol> <li>Listas, Mapas y Set<ol> <li>M\u00e9todos y operaciones comunes de colecciones.</li> </ol> </li> </ol> </li> <li>Funciones en Dart<ol> <li>Declaraci\u00f3n de funciones</li> <li>Par\u00e1metros y valores de retorno</li> <li>Funciones an\u00f3nimas y funciones de flecha</li> </ol> </li> <li>Conceptos B\u00e1sicos de POO<ol> <li>Clases y objetos.</li> <li>Uso de modificadores de acceso (public, private)</li> <li>Paquetes y bibliotecas en Dart</li> <li>Manejo de Excepciones<ol> <li>Try, catch.</li> </ol> </li> </ol> </li> <li>Programaci\u00f3n as\u00edncrona<ol> <li>then</li> <li>Future</li> </ol> </li> <li>Proyecto Final</li> </ol>"},{"location":"dart/","title":"Instalaci\u00f3n y Configuraci\u00f3n de Dart y Flutter","text":"<p>La manera mas sencilla de instalar Dart si sera usado en un futuro con Flutter, es desde su sitio oficial.</p>"},{"location":"dart/#configuracion-en-windows","title":"Configuraci\u00f3n en Windows","text":""},{"location":"dart/#descargar-flutter","title":"Descargar Flutter","text":"<ol> <li>Descargar el archivo <code>zip</code> de la pagina oficial Descarga</li> </ol> <ol> <li>Una vez descargado, descomprimirlo y la carpeta generada, debe ser colocada en algun directorio seguro. Ejemplo</li> <li><code>%USERPROFILE%\\flutter</code></li> <li><code>D:\\dev\\flutter</code></li> </ol> <p>Warning</p> <p>No guardarlo en <code>C:\\Program Files\\</code> porque requiere privilegios de administrador, ademas que no tiene caso.</p>"},{"location":"dart/#configuracion-del-path","title":"Configuraci\u00f3n del <code>PATH</code>","text":"<p>Comprobar el path con dart y flutter, correr flutter doctor y ya, continuar en la seccion de flutter con android estudio</p> <p>TODO: Verificar en la consola que todo funcione bien</p>"},{"location":"dart/#editor-de-codigo","title":"Editor de c\u00f3digo","text":""},{"location":"dart/#descargando-e-instalando-visual-studio-code","title":"Descargando e instalando Visual Studio Code","text":"<p>Para el uso de Dart (Con Flutter se vera despu\u00e9s), vamos a utilizar Visual Studio Code.</p> <p>Note</p> <p>Descargar de su sitio oficial Aqu\u00ed</p> <p>TODO: Agregar la imagen del sitio</p> <p>TODO: Agregar la secuencia de la instalacion</p>"},{"location":"dart/#agregando-plugins-a-vs-code","title":"Agregando plugins a VS Code","text":"<ol> <li>Nos debemos ir a la secci\u00f3n de instalaci\u00f3n de <code>Extensiones</code> de VS Code</li> <li>En el buscador escribimos <code>dart</code>, para encontrar el plugin oficial</li> <li>Damos en el bot\u00f3n de instalar, esperamos y quedara instalado</li> </ol> <p>Verificamos que este instalado correctamente como se ve en la imagen</p> <p></p> <p>Realizando todo esto, nuestro entorno estar\u00e1 listo para comenzar a programar con dart.</p> <p>Informaci\u00f3n del sitio oficial</p>"},{"location":"dart/01.sintaxis/","title":"Sintaxis b\u00e1sica de Dart","text":""},{"location":"dart/01.sintaxis/#hello-word-con-dart","title":"Hello Word con Dart","text":"<ol> <li>Crear un archivo nuevo, darle el nombre de <code>main.dart</code></li> <li>Escribir en el :</li> </ol> main.dart<pre><code>// Nuestro primer programa\n\nvoid main(){\n    print(\"Hello Word\");\n}\n</code></pre> <p>Para probar nuestro primer programa, abrimos la terminal</p> <pre><code>dart main.dart\n</code></pre> <p>Obtenemos en la salida</p> <pre><code>    Hello Word\n</code></pre>"},{"location":"dart/01.sintaxis/#comentarios","title":"Comentarios","text":"<p>Los comentarios nos ayudan a documentar o darnos pistas dentro del c\u00f3digo. Todo comentario sera ignorado por el compilador, no importa que el comentario contenga lineas de c\u00f3digo validas y correctas, el compilador simplemente lo pasara por alto.</p> <p>Hay dos tipos bloque de comentario</p> <ol> <li>Una linea</li> <li>Multi linea</li> </ol>"},{"location":"dart/01.sintaxis/#comentario-de-una-linea","title":"Comentario de una linea","text":"<p>Para agregar comentario en un linea del archivo se inicia con doble diagonal (<code>slash</code>) (<code>//</code>). Cuando se coloca doble slash, a partir de ahi todo lo que esta delante se convierte en comentario y el compilador de ignora</p> <pre><code>// Esto es un comentario\n// Otro comentario de una linea\n</code></pre>"},{"location":"dart/01.sintaxis/#bloque-de-comentario-o-multi-linea","title":"Bloque de comentario o multi linea","text":"<p>Este tipo de bloque de comentario nos sirve para envolver varias lineas de c\u00f3digo, sin la necesidad de estar colocando en cada linea <code>doble slash</code>. El bloque de comentario debe iniciar con diagonal junto con un asterisco (<code>/*</code>) y cerrando el bloque con asterisco y diagonal (<code>*/</code>)</p> <pre><code>/* inicia el bloque de comentario\n    Bloque de comentario\n    Continua siendo comentario\n    ...\n\ntermina el bloque de comentario */\n</code></pre>"},{"location":"dart/01.sintaxis/#variables-y-tipos-de-datos","title":"Variables y tipos de datos","text":"<p>Note</p> <p>Toda sentencia termina con punto y come (<code>;</code>).</p>"},{"location":"dart/01.sintaxis/#tipos-de-datos-en-dart","title":"Tipos de datos en Dart","text":"<p>Dart soporta los siguientes tipos de datos, aqu\u00ed solo usaremos los mas importantes y b\u00e1sicos.</p> <ul> <li>Numbers (int, double)</li> <li>Strings (String)</li> <li>Booleans (bool)</li> <li>Lists (List, also known as arrays)</li> <li>Sets (Set)</li> <li>Maps (Map)</li> <li>Object: The superclass of all Dart classes except Null.</li> <li>Enum: The superclass of all enums.</li> <li>Future and Stream: Used in asynchrony support.</li> <li>Iterable: Used in for-in loops and in synchronous generator functions.</li> <li>The value null (Null)</li> <li>dynamic (din\u00e1mico, cualquiera de los anteriores)</li> </ul>"},{"location":"dart/01.sintaxis/#numbers-numeros","title":"Numbers (N\u00fameros)","text":""},{"location":"dart/01.sintaxis/#int-entero","title":"int (entero)","text":"<p>El valor int (entero) no tan largo que 64 btis, dependiendo de la plataforma. En plataformas nativa el valor va desde -2<sup>63</sup> hasta 2<sup>63</sup> -1, en la web es de el valor va desde -2<sup>53</sup> hasta 2<sup>53</sup> -1</p> <pre><code>int numero1 = 23;\nint numero2 = 34234;\nint numero3 = -6;\n</code></pre>"},{"location":"dart/01.sintaxis/#doble-doble-o-real","title":"doble (Doble o Real)","text":"<p>Precision de 64 bits con punto flotante, como marca la especificaci\u00f3n del est\u00e1ndar IEEE 754</p> <pre><code>double numero1 = 0.4;\ndouble numero2 = -23.23;\ndouble numero3 = 546.34;\n</code></pre>"},{"location":"dart/01.sintaxis/#strings","title":"Strings","text":"<p>Un <code>String</code> en Dart es una secuencia de c\u00f3digos UTF-16. Se puede utilizar comillas simples (<code>''</code>) o comillas dobles (<code>\"\"</code>), para envolver la cadena de caracteres.</p>"},{"location":"dart/01.sintaxis/#cadena-en-una-linea","title":"Cadena en una linea","text":"<pre><code>String s1 = 'Single quotes work well for string literals.';\nString s2 = \"Double quotes work just as well.\";\nString s3 = 'It\\'s easy to escape the string delimiter.';\nString s4 = \"It's even easier to use the other delimiter.\";\n</code></pre>"},{"location":"dart/01.sintaxis/#cadena-en-multi-linea","title":"Cadena en multi linea","text":"<pre><code>String s1 = '''\nYou can create\nmulti-line strings like this one.\n''';\n\nString s2 = \"\"\"This is also a\nmulti-line string.\"\"\";\n</code></pre>"},{"location":"dart/01.sintaxis/#declaracion-de-variables","title":"Declaraci\u00f3n de variables","text":"<p>La forma de declarar variables, tiene la siguiente estructura:</p> <pre><code>tipo_de_dato nombre_de_variable = valor ;\n</code></pre> <p> </p>"},{"location":"dart/01.sintaxis/#booleans","title":"Booleans","text":"<p>La representaci\u00f3n de un valor booleano, tiene el nombre de <code>bool</code> en Dart. Solo puede contener dos tipos de valores <code>false</code> y <code>true</code>.</p> <pre><code>bool isAlive = true;\nbool isEmpty = false;\nbool isLogin = false;\n</code></pre>"},{"location":"dart/01.sintaxis/#funcion-print","title":"Funci\u00f3n <code>print()</code>","text":"<p>La funci\u00f3n print nos sirve para enviar mensajes o informaci\u00f3n a la salida est\u00e1ndar del sistema (stdout). Se coloca la palabra <code>print</code> y entre sus par\u00e9ntesis todos los argumentos que queramos colocar, puede ser cualquier tipo de dato.</p> <pre><code>print(\"Hola mundo\");\n\nprint(4 + 3);\n\nprint(variable);\n</code></pre> <p> </p>"},{"location":"dart/01.sintaxis/#estructura-base-de-un-programa-dart","title":"Estructura base de un programa Dart","text":"<p>La estructura de todo archivo Dart que queramos ejecutar debe contener forzosamente la funci\u00f3n <code>main</code>. Por el momento asi estaremos trabajando</p> <p>Note</p> <p>Todo el c\u00f3digo que escribamos debe estar dentro de la funci\u00f3n <code>main()</code>, SIEMPRE. En un futuro aprenderemos qu\u00e9 y c\u00f3mo se debe y puede escribir fuera de ella.</p> <pre><code>//funci\u00f3n main\n\nvoid main(){ //inicia la funci\u00f3n\n    //contenido del programa\n    print(\"Hola mundo\");\n\n}//termina la funci\u00f3n main\n</code></pre> <p> </p>"},{"location":"dart/01.sintaxis/#ejercicios","title":"Ejercicios","text":"<ol> <li>Declarar 5 variables, que sean de diferente tipo, es decir, entero, flotante, booleano y String</li> <li>Declarar 3 variables de tipo entero, y despu\u00e9s mandarlos a imprimir</li> <li>Declarar 3 variables de tipo flotante, despu\u00e9s mandarlos a imprimir</li> <li>Declarar 3 variables de tipo String; el mensaje puede ser cual sea, despu\u00e9s mandarlos a imprimir</li> </ol> <p>M\u00e1s informaci\u00f3n en: https://dart.dev/language/built-in-types</p>"},{"location":"dart/02.operadores/","title":"Operadores b\u00e1sicos","text":"<p>Existen diversos tipos de operadores, para diferentes aplicaciones.</p> <ul> <li>Operadores Aritm\u00e9ticos</li> <li>Operadores de relaci\u00f3n e igualdad</li> <li>Operadores l\u00f3gicos</li> <li>Operadores de prueba de tipos</li> <li>Operadores de asignaci\u00f3n</li> </ul>"},{"location":"dart/02.operadores/#operadores-aritmeticos","title":"Operadores Aritm\u00e9ticos","text":"<p>Las operaciones aritm\u00e9ticas que tiene el lenguaje <code>dart</code> son las siguientes:</p> Operador Significado <code>+</code> Suma <code>-</code> Resta <code>-expr</code> Negaci\u00f3n <code>*</code> Multiplicaci\u00f3n <code>/</code> Division <code>~/</code> Division, resultado en entero <code>%</code> Residuo o m\u00f3dulo <code>=</code> Asignaci\u00f3n <p>Son los \u00fanicos operadores que existen en este lenguaje (puede ser que el futuro agreguen alguno)</p>"},{"location":"dart/02.operadores/#operadores-de-relacion-e-igualdad","title":"Operadores de relaci\u00f3n e igualdad","text":"<p>Estos operadores no ayudan a comparar variables, son los siguientes</p> S\u00edmbolo Significado <code>==</code> Igual que <code>!=</code> Diferente de <code>&gt;</code> Mayor que <code>&lt;</code> Menor que <code>&gt;=</code> Mayor o igual que <code>&lt;=</code> Menor o igual que <p>Ejecuta los siguientes ejemplos:</p> <pre><code>print(2 == 2);\nprint(2 != 3);\nprint(3 &gt; 2);\nprint(2 &lt; 3);\nprint(3 &gt;= 3);\nprint(2 &lt;= 3);\n</code></pre> <p>Al ser una comparaci\u00f3n, los \u00fanicos valores posibles que se pueden obtener son booleanos, es decir, verdadero o falso, dependiendo de lo que se esta comparando.</p> <p>Ejemplos de aplicaci\u00f3n de los operadores aritm\u00e9ticos:</p> <pre><code>print(2 + 3);\nprint(2 - 3);\nprint(2 * 3);\nprint(5 / 2);\nprint(5 ~/2);\nprint(5 % 2);\n\nint resultado = 5 ~/ 2;\nprint('5/2 = ${resultado}');\n</code></pre>"},{"location":"dart/02.operadores/#operador-de-pre-y-post-incrementodecremento","title":"Operador de pre y post incremento/decremento","text":"<p>Contamos con 2 operadores y prefijo o sufijo. Estos son una contracci\u00f3n de una operaci\u00f3n de incremento o decremento, el cual puede ser puede tambi\u00e9n realizar con una operacion basica pero este seria un <code>shorthand</code>, es decir, una version corta o abreviada de la operaci\u00f3n.</p> Operador Nombre Equivalencia <code>++var</code> Pre-incremento <code>var = var + 1</code> <code>var++</code> Post-incremento <code>var = var + 1</code> <code>--var</code> Pre-decremento <code>var = var - 1</code> <code>var--</code> Post-decremento <code>var = var - 1</code> <pre><code>void main() {\nint var1 = 3;\nint var2 = 7;\n\nprint(var1++); //incrementa DESPU\u00c9S de la ejecuci\u00f3n del print\nprint(++var1); //incrementa ANTES de la ejecuci\u00f3n del print\nprint(var2--); //decrementa DESPU\u00c9S de la ejecuci\u00f3n del print\nprint(--var2); //decrementa ANTES de la ejecuci\u00f3n del print\n}\n</code></pre> <p>Salida:</p> <pre><code>3\n5\n7\n5\n</code></pre>"},{"location":"dart/02.operadores/#operadores-de-asinacion-combinado","title":"Operadores de asinacion combinado","text":"<p>Estos operadores son un <code>shorthand</code> o contracci\u00f3n de operaciones matem\u00e1ticas, se ocupan para escribir menos, pero al final realizan la misma operaci\u00f3n matem\u00e1tica que representa.</p> S\u00edmbolo Aplicaci\u00f3n Equivalencia <code>*=</code> <code>a *= 3</code> <code>a = a * 3</code> <code>/=</code> <code>a /= 3</code> <code>a = a / 3</code> <code>%=</code> <code>a %= 3</code> <code>a = a % 3</code> <code>+=</code> <code>a += 3</code> <code>a = a + 3</code> <code>-=</code> <code>a -= 3</code> <code>a = a - 3</code> <code>~/=</code> <code>a ~/= 3</code> <code>a = a ~/ 3</code> <pre><code>int a = 2; // Assign using =\na *= 3; // Assign and multiply: a = a * 3\nprint(a == 6);\n</code></pre> <p>Existen mas operadores, para mas informaci\u00f3n ir al documentaci\u00f3n oficial de dart en https://dart.dev/language/operators#assignment-operators</p>"},{"location":"dart/02.operadores/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Los operadores l\u00f3gicos solo pueden ser aplicados con el tipo de dato <code>bool</code>, por lo tanto debe venir de una comparaci\u00f3n o de un valor booleano.</p> Operador S\u00edmbolo <code>&amp;&amp;</code> operador AND (Y) <code>||</code> operador OR (O) <code>!</code> operador NOT (inversora)"},{"location":"dart/02.operadores/#tablas-de-operadores-logicos","title":"Tablas de operadores l\u00f3gicos","text":""},{"location":"dart/02.operadores/#and","title":"AND","text":"Valor 1 Valor 2 Resultado <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code>"},{"location":"dart/02.operadores/#or","title":"OR","text":"Valor 1 Valor 2 Resultado <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code> <code>true</code>"},{"location":"dart/02.operadores/#not","title":"NOT","text":"Valor 1 Resultado <code>false</code> <code>true</code> <code>true</code> <code>false</code> <pre><code>void main() {\nbool valor1 = true;\nbool valor2 = false;\n\nprint(\"${valor1 &amp;&amp; valor2}\");\nprint(\"${valor2 || valor1}\");\nprint(\"${!(valor2 || valor1)}\");\nprint(\"${!valor1}\");\n}\n</code></pre> <p>Para una aplicaci\u00f3n mayor ir a secci\u00f3n de decisiones</p>"},{"location":"dart/02.operadores/#jerarquia-de-operadores","title":"Jerarqu\u00eda de operadores","text":"Orden Nombre Operadores 1 post unitario <code>expr++</code> <code>expr--</code> <code>( )</code> <code>[]</code> <code>?[ ]</code> <code>.</code> <code>?.</code> <code>!</code> 2 pre unitario <code>-expr</code> <code>!expr</code> <code>~expr</code> <code>++expr</code> <code>--expr</code> <code>await expr</code> 3 multiplicativos <code>*</code> <code>/</code> <code>%``~/</code> 4 aditivos <code>+</code> <code>-</code> 5 de relaci\u00f3n o test <code>&gt;=``&gt;``&lt;=``&lt;``as``is``is!</code> 6 igualdad <code>==</code> <code>!=</code> 7 l\u00f3gico AND <code>&amp;&amp;</code> 8 l\u00f3gico OR <code>||</code> 9 if null <code>??</code> 10 operador ternario <code>expr1 ? expr2 : expr3</code> 11 cascada <code>..</code> <code>?..</code> 12 asignaci\u00f3n <code>=</code> <code>*=</code> <code>/=</code> <code>+=</code> <code>-=</code> <code>&amp;=</code> <code>^=</code>"},{"location":"dart/02.operadores/#ejercicios","title":"Ejercicios","text":""},{"location":"dart/02.operadores/#operadores-aritmeticos_1","title":"Operadores aritm\u00e9ticos","text":"<ol> <li>Realizar la suma de 2 n\u00fameros</li> <li>Realizar la resta de 3 n\u00fameros</li> <li>Realizar la suma de 3 n\u00fameros, despu\u00e9s ese resultado multiplicarlo por 2, a este resultado dividirlo entre 3, e imprimir el resultado.</li> </ol>"},{"location":"dart/02.operadores/#operadores-de-relacion-e-igualdad_1","title":"Operadores de relaci\u00f3n e igualdad","text":"<ol> <li>Comparar si 5 es igual a 9, he imprime el resultado</li> <li>Comparar si 5 es diferente de 9, he imprime el resultado</li> <li>Comparar si 35 es menor que 100, he imprime el resultado</li> </ol> <p>Mas informaci\u00f3n en la documentaci\u00f3n oficial</p>"},{"location":"dart/03.strings/","title":"Cadenas de texto (String)","text":"<p>Los <code>strings</code> o cadena de caracteres nos sirven para guardar texto, este texto pueden ser n\u00fameros, letras, s\u00edmbolos, emojis, etc.</p> <p>Formas de declarar strings</p> <pre><code>String s1 = 'Single quotes work well for string literals.';\nString s2 = \"Double quotes work just as well.\";\nString s3 = 'It\\'s easy to escape the string delimiter.';\nString s4 = \"It's even easier to use the other delimiter.\";\nString s5 = \"\"\"Este texto es multilinea, que a su ves saldr\u00e1 de esta manera\ncon los saltos de lineas que se agreguen\n\"\"\";\nString s6 = '''Este texto es multilinea, que a su ves saldr\u00e1 de esta manera\nse puede usar comillas simples\n''';\n</code></pre>"},{"location":"dart/03.strings/#concatenacion","title":"Concatenaci\u00f3n","text":"<p>La concatenaci\u00f3n es la union o combinaci\u00f3n de varios strings, esto se puede realizar de dos maneras (hay mas, pero estas son las usuales)</p> S\u00edmbolo Aplicaci\u00f3n Nota <code>+</code> <code>var1 + var2</code> <code>$</code> <code>\"$var1 $var2\"</code> El signo de peso debe estar dentro de la doble comillas o comillas simples <code>$</code> <code>\"${var1 + $var2}\"</code> El signo de peso debe estar dentro de la doble comillas o comillas simples; pero cuando se quiere hacer una operaci\u00f3n extra se debe colocar llaves <pre><code>void main() {\n  String mensaje1 = \"Hola \" + \"mundo\";\n\n  String palabra = \"Dart\";\n  String mensaje2 = \"$mensaje1, soy Programador $palabra \";\n\n  String mensaje3 = \"${mensaje1 + mensaje2}\";\n  print(mensaje1);\n  print(mensaje2);\n  print(mensaje3);\n}\n</code></pre>"},{"location":"dart/03.strings/#conversion-a-string","title":"Conversion a String","text":"<p>Cuando estamos realizando operaciones matem\u00e1ticas, necesitamos pasar este tipo de dato a string, o cualquier otro tipo. Para esto cada objeto tiene sus m\u00e9todos para hacer esa conversion.</p> <p>Pr\u00e1cticamente todos los objetos tienen su m\u00e9todo para convertir a String.</p> <pre><code>void main() {\n  int valor1 = 43;\n  double valor2 = 34.23;\n  bool booleano = true;\n\n  String valorEntero = valor1.toString();\n  String valorDouble = valor2.toString();\n  String valorBool = booleano.toString();\n\n  String mensaje1 = \"El valor entero es \" + valorEntero;\n  String mensaje2 = \"El valor double es \" + valorDouble;\n  String mensaje3 = \"El valor bool es \" + valorBool;\n\n  print(mensaje1);\n  print(mensaje2);\n  print(mensaje3);\n}\n</code></pre>"},{"location":"dart/03.strings/#secuencias-de-escape","title":"Secuencias de escape","text":"Secuencia de escape Significado <code>\\n</code> Salto de linea <code>\\t</code> Tabulador <code>\\r</code> Retorno de carro <code>\\'</code> Comillas simple <code>\\\"</code> Comillas dobles <code>\\\\</code> Back slash <pre><code>void main(){\n\n    print(\"Este es un mensaje\\ncon salto de linea\")\n    print(\"Mensaje con\\ttabulation\");\n    print(\"Mensaje con \\\"dobles comillas\\\"\");\n    print(\"Mensaje con \\'comillas simples\\'\");\n    print(\"Varios saltos de linea\\n\\n\\n3saltos\");\n}\n</code></pre> <p>Salida</p> <pre><code>    Este es un mensaje\n    con salto de linea\n    Mensaje con     tabulation\n    Mensaje con \"dobles comillas\"\n    Mensaje con 'comillas simples'\n    Varios saltos de linea\n\n\n    3saltos\n</code></pre>"},{"location":"dart/03.strings/#ejercicios","title":"Ejercicios","text":"<ol> <li>Declarar una variable con un mensaje y mandarlo a la pantalla</li> <li>Declarar 2 variables, cada una con un texto diferente para concatenarlas e imprimir la frase completa</li> <li>Mandar un string en la funci\u00f3n <code>print</code>, pero dentro de este string realizar la concatenaci\u00f3n de 2 variables string</li> </ol>"},{"location":"dart/04.entrada_de_datos/","title":"Entrada de datos (stdin)","text":"<p>Para realizar aplicaciones sencillas o de terminal necesitamos en muchas ocasiones recibir par\u00e1metros del usuario, esto debe ser solicitado al usuario para que con base a esa informaci\u00f3n nuestro programa actu\u00e9. Esto lo podemos realizar con la funci\u00f3n <code>readLineSync</code>, que viene en objeto <code>stdin</code>, como el mismo nombre lo indica es la entrada por terminal o consola, como se muestra en el ejemplo siguiente:</p> <pre><code>// importing dart:io file y convert\nimport 'dart:convert';\nimport 'dart:io';\n\nvoid main(){\n print(\"Enter your name?\");\n // Se lee desde la terminal el texto introducido\n String name = stdin.readLineSync(encoding: utf8)!;// se colocar ! para forzar el ingreso \"seguro\" de datos\n\n // Printing the name\n print(\"Hola, $name . Eres todo un programador dart!\");\n}\n</code></pre> <p>Le indicamos la codificaci\u00f3n en la que debe interpretar lo que vayamos a escribir, esto es por los s\u00edmbolos especiales que tiene el idioma espanol, como lo son por ejemplo la <code>\u00f1</code>.</p>"},{"location":"dart/04.entrada_de_datos/#ejemplos","title":"Ejemplos","text":"<ol> <li>Suma de 2 n\u00fameros en memoria e imprimir el resultado (Datos ingresados por el usuario)</li> <li>Multiplicaci\u00f3n de 2 n\u00fameros en memoria e imprimir el resultado (Datos ingresados por el usuario)</li> <li>Calcular el per\u00edmetro de [cuadrado|rect\u00e1ngulo]. (Datos ingresados por el usuario).La salida del mensaje sera: El per\u00edmetro de la figura es 43.59 u</li> <li>Calcular el \u00e1rea de un triangulo (Datos ingresados por el usuario). La salida del mensaje sera: El \u00e1rea del triangulo es 45.23 u^2</li> <li>Calcular el promedio de una materia, son 3 unidades. La salida del mensaje sera: La calificaci\u00f3n es 4.32</li> </ol>"},{"location":"dart/04.entrada_de_datos/#ejercicios","title":"Ejercicios","text":"<ol> <li>Realizar el c\u00e1lculo del per\u00edmetro de un cuadrado, con datos en memoria, e imprimir el resultado</li> <li>Realizar el c\u00e1lculo del per\u00edmetro de un rect\u00e1ngulo, solicitando el lado de la figura al usuario, e imprimir el resultado</li> <li>Realizar el c\u00e1lculo del area de un cuadrado, solicitando el lado de la figura al usuario, e imprimir el resultado</li> <li>Realizar un programa que realice el c\u00e1lculo de Fuerza en la segunda Ley de Newton. La formula es \\(Fuerza = masa * aceleraci\u00f3n\\). Solicitando el lado de la figura al usuario, e imprimir el resultado.</li> <li>Realizar una calculadora que convierta de cent\u00edmetros a pulgadas,  solicitando el lado de la figura al usuario, e imprimir el resultado.</li> <li>Hacer una caja registradora, que reciba el valor del producto y al final entregue el costo total con IVA y sin IVA; es decir, En total es $18.35 y con IVA son $21.28, recordar que el IVA es del 16%.</li> </ol>"},{"location":"dart/05.math/","title":"Librer\u00eda math","text":"<p>Como en la mayor\u00eda de lenguajes cuenta con su librer\u00eda con funciones y constantes matem\u00e1ticas, dart no es la excepci\u00f3n, aqu\u00ed abarcaremos una parte de ella.</p> <p>Primero debemos importar la librer\u00eda para poder hacer uso de sus funciones, eso lo hacemos de la siguiente manera:</p> <pre><code>import 'dart:math';\n</code></pre>"},{"location":"dart/05.math/#constantes","title":"Constantes","text":"<p>De las constantes que mas nos pueden interesar son:</p> <ul> <li>PI</li> <li>Euler (E)</li> </ul> <pre><code>import 'dart:math';\n\nvoid main() {\n  print(\"El valor de pi: $pi\");\n  print(\"El valor de e: $e\");\n}\n</code></pre>"},{"location":"dart/05.math/#metodos","title":"M\u00e9todos","text":"<p>De los m\u00e9todos que nos pueden interesar son:</p> <ul> <li>Identidades trigonom\u00e9tricas (Todo es en radianes)<ul> <li>Seno</li> <li>Coseno</li> <li>Tangente</li> </ul> </li> <li>Ra\u00edz cuadrada</li> <li>Exponente</li> <li>M\u00e1ximo</li> <li>M\u00ednimo</li> </ul> <pre><code>import 'dart:math';\n\nvoid main() {\n\n  double raizCuadrada = sqrt(25);\n  double exponente = exp(2);\n  double coseno = cos(45);\n  double seno = sin(45);\n  double tangente = tan(45);\n  double potencia = pow(2,3); //ambos argumentos deben ser enteros\n\n\n  print(\"La ra\u00edz cuadrada de 25 es: $raizCuadrada\");\n  print(\"El exponencial de e^2 es: $exponente\");\n  print(\"La elevar 2 al cubo (2^3) es: $potencia\");\n  print(\"El coseno de 45 es: $coseno\");\n  print(\"El seno de 45 es: $seno\");\n  print(\"La tangente de 45 es: $tangente\");\n}\n</code></pre>"},{"location":"dart/05.math/#random","title":"Random","text":"<p>Otro objeto que viene dentro de la librer\u00eda <code>math</code> es el objeto random, que no sirve para generar u obtener n\u00fameros al azar o randoms.</p> <pre><code>import 'dart:math';\n\nvoid main() {\n  var intValue = Random().nextInt(10); // Value is &gt;= 0 and &lt; 10.\n  var doubleValue = Random().nextDouble(); // Value is &gt;= 0.0 and &lt; 1.0.\n  var boolValue = Random().nextBool(); // true or false, with equal chance.\n\n  print(\"Random entero: $intValue\");\n  print(\"Random double: $doubleValue\");\n  print(\"Random booleano: $boolValue\");\n}\n</code></pre>"},{"location":"dart/05.math/#ejemplos","title":"Ejemplos","text":"<ul> <li>Calcular la potencia de un n\u00famero, solicita al usuario el n\u00famero que desea elevar y despu\u00e9s la base a la cu\u00e1l lo elevara. Ejemplo: \\(2^2 = 4\\); \\(2^3 = 8\\)</li> </ul>"},{"location":"dart/05.math/#ejercicios","title":"Ejercicios","text":"<ul> <li>Resolver ecuaci\u00f3n de segundo orden, aplicando la f\u00f3rmula general; recuerda que no existen las ra\u00edces negativas. Debe entregarte los valores de las ra\u00edces o en caso que alguna o ninguna ra\u00edz exista, indicarlo. Nota: Debes usar las funciones matem\u00e1ticas que vienen en el lenguaje</li> <li>Realizar una calculadora de Teorema de Pit\u00e1goras, el usuario debe elegir, cateto opuesto, adyacente o hipotenusa, salir, que desear calcular. Nota: Debes usar las funciones matem\u00e1ticas que vienen en el lenguaje</li> </ul> <p>Mas informaci\u00f3n en https://api.dart.dev/stable/3.2.4/dart-math/dart-math-library.html \u00ba</p>"},{"location":"dart/06.decisiones/","title":"Estructuras de decisiones","text":"<p>La estructura de decisiones que vamos a estar aprendiendo ser\u00e1n <code>if</code> e <code>if-else</code>. Tenemos <code>switch</code>, sin embargo no se abarcaran aun.</p>"},{"location":"dart/06.decisiones/#estructura-basica-if","title":"Estructura b\u00e1sica <code>if</code>","text":"<p>La sentencia <code>if</code> nos ayuda a dar un control de flujo de la aplicaci\u00f3n, siempre verificando una situaci\u00f3n verdadera.</p> <p></p> <p></p> <pre><code>void main() {\n  int valor1 = 4;\n  int valor2 = 7;\n\n  if (valor1 &lt; valor2) {\n    print(\"$valor1 &lt; $valor2\");\n  }\n  if (valor1 &gt; valor2) {\n    print(\"$valor1 &gt; $valor2\");\n  }\n  if (valor1 &gt;= valor2) {\n    print(\"$valor1 &gt;= $valor2\");\n  }\n  if (valor1 &lt;= valor2) {\n    print(\"$valor1 &lt;= $valor2\");\n  }\n  if (valor1 == valor2) {\n    print(\"$valor1 == $valor2\");\n  }\n  if (valor1 != valor2) {\n    print(\"$valor1 != $valor2\");\n  }\n}\n</code></pre> <p>Siempre que se cumpla una condici\u00f3n, se ingresa al bloque dentro de las llaves y todo el c\u00f3digo escrito ahi, se ejecutara.</p>"},{"location":"dart/06.decisiones/#estructura-if-else","title":"Estructura <code>if-else</code>","text":"<p>La palabra reservada <code>else</code> complementa al <code>if</code>, es en la \u00fanica forma que lo vamos a encontrar. Esto se lee como, <code>si</code> cumple con la condici\u00f3n, act\u00faa el bloque de <code>if</code>, de lo contrario hago lo que esta en el otro bloque.</p> <pre><code>void main() {\n  int valor1 = 4;\n  int valor2 = 7;\n\n  if (valor1 &lt; valor2) {\n    print(\"$valor1 &lt; $valor2\");\n  } else if (valor1 &gt; valor2) {\n    print(\"$valor1 &gt; $valor2\");\n  } else if (valor1 &gt;= valor2) {\n    print(\"$valor1 &gt;= $valor2\");\n  } else if (valor1 &lt;= valor2) {\n    print(\"$valor1 &lt;= $valor2\");\n  } else if (valor1 == valor2) {\n    print(\"$valor1 == $valor2\");\n  } else if (valor1 != valor2) {\n    print(\"$valor1 != $valor2\");\n  }\n}\n</code></pre>"},{"location":"dart/06.decisiones/#operador-ternario","title":"Operador ternario","text":"<p>Es una simplificaci\u00f3n de un <code>if-else</code>. Que solo puede ejecutar una acci\u00f3n.</p> <pre><code>tipo variable = comparaci\u00f3n ? resultado_verdadero : resultado_falso;\n</code></pre> <p> </p>"},{"location":"dart/06.decisiones/#comparacion-de-operador-ternario-vs-if-else","title":"Comparaci\u00f3n de operador ternario vs <code>if-else</code>","text":"<pre><code>print(\"Cual es tu edad?\");\nint edad = int.parse(stdin.readLineSync(encoding: utf8)!);\n\nString resultado = edad &gt;= 18 ? \"Ya eres mayor\" : \"Aun eres muy joven\";\n  String resultado2 = \"\";\n  if (edad &gt;= 18){\n      resultado2 = \"Ya eres mayor\";\n  }else{\n       resultado2 = \"Aun eres muy joven\";\n  }\nprint(\"Eres mayor : $resultado\");\nprint(\"Eres mayor : $resultado2\");\n</code></pre>"},{"location":"dart/06.decisiones/#concatenacion-de-operador-ternario","title":"Concatenaci\u00f3n de operador ternario","text":"<pre><code>print(\"Escribe un texto para convertir a may\u00fascula o min\u00fasculas\");\nString texto = stdin.readLineSync(encoding: utf8)!;\nprint(\"1)Min\u00fasculas\\t2)May\u00fasculas\");\nint opt = int.parse(stdin.readLineSync(encoding: utf8)!);\nString resultado = opt == 1 ? texto.toLowerCase():\n                   opt == 2 ? texto.toUpperCase(): \"Opcion no existe\";\n\nprint(resultado == \"Opcion no existe\" ? resultado : \"El nuevo texto: $resultado\");\n</code></pre>"},{"location":"dart/06.decisiones/#ejemplos","title":"Ejemplos","text":"<ul> <li>Preguntar la edad, \"Ya eres mayor de edad\": \"Aun eres muy joven\"</li> <li>Solicitar al usuario la cantidad de mascotas que tiene en casa, si no tiene o cuenta con hasta 3, se le manda el mensaje: \"Te hacen falta m\u00e1s mascotas\", de lo contrario el mensaje sera \"Eres amante de los animales\". (Usando exclusivamente if)</li> <li>Verificar si un numero es \"par\" o \"impar\"</li> <li>Dar 2 n\u00fameros e indicar cual es el menor de los 2, en caso que sean iguales debe indicar que son iguales</li> <li>Dar 3 n\u00fameros e indicar cual es el menor de los 3, en caso que sean iguales debe indicar que son iguales</li> <li>Calculadora del rect\u00e1ngulo,<ul> <li>1.- per\u00edmetro</li> <li>2.- area</li> <li>en caso que de otra opci\u00f3n indicar que \"no existe la opci\u00f3n\"</li> </ul> </li> </ul>"},{"location":"dart/06.decisiones/#ejercicios","title":"Ejercicios","text":""},{"location":"dart/06.decisiones/#if-else","title":"If-else","text":"<ul> <li>Hacer una calculadora de \u00e1reas geom\u00e9tricas, las opciones son:</li> <li>\u00c1rea del cuadrado</li> <li>\u00c1rea del c\u00edrculo</li> <li>\u00c1rea del tri\u00e1ngulo</li> <li>Con opci\u00f3n de salir del programa y al final imprimir el resultado con la frase \"El \u00e1rea de la figura 'nombre' es\"</li> <li>Ley de ohm, solicitar la variable a calcular, solicitar los datos e imprimir el resultado con su respectiva unidad. La formula es \\(I = \\frac{V}{R}\\)</li> <li>Hacer una caja registradora, que reciba el valor del producto y al final entregue el costo total con IVA y sin IVA; es decir, En total es $18.35 y con IVA son $21.28, recordar que el IVA es del 16%</li> </ul>"},{"location":"dart/06.decisiones/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<ul> <li> <p>Solicitar al usuario su promedio actual, en valor entero, el algoritmo debe tomar la decisi\u00f3n con bas\u00e9 al n\u00famero ingresado, y dar un mensaje (ver la tabla)</p> Rango de calificaci\u00f3n Mensaje a imprimir 0 a menor que 6 \"lastima margarito\" 6 a menor que 7 \"Apl\u00edcate\" 7 a menor que 8 \"Apenitas y la libraste, metele pap\u00ed\" 8 a menor que 9 \"Bastante bien, puedes mejorar\" 9 a menor que 10 \"muy bien amiguito, te ganaste la cheve!\" Igual a 10 \"Excelente, tu muy bien\" Menor a 0 y mayor a 10 \"Calificaci\u00f3n no posible\" </li> <li> <p>C\u00e1lculo de BMI (Indice de Masa Corporal) para peso y altura, indicando cual es tu BMI y en que nivel de obesidad te encuentras (Ver tabla). La formula es \\(BMI = peso (kg) * estatura^2 (cm)\\)</p> IMC Nivel de peso Por debajo de 18.5 Bajo peso 18.5 \u2013 24.9 Normal 25.0 \u2013 29.9 Sobrepeso 30.0 o m\u00e1s Obesidad </li> <li> <p>Mandar la letra del m\u00faltiplo o submultiple correspondiente, es decir, si el usuario ingresa el valor de 1,000, el valor que se debe desplegar por pantalla es la letra \"K\", si el usuario ingresa el valor de 0.02, se debe desplegar por pantalla la letra \"m\"</p> Unidad Letra Valor pico p \\(\\times 10^{-12}\\) nano n \\(\\times 10^{-9}\\) micro u \\(\\times 10^{-6}\\) mili m \\(\\times 10^{-3}\\) unidad 1 kilo K \\(\\times 10^{3}\\) mega M \\(\\times 10^{6}\\) giga G \\(\\times 10^{9}\\) </li> </ul>"},{"location":"dart/07.loops/","title":"Ciclos","text":"<p>Los ciclos son estructuras de repetici\u00f3n, todo lo que este dentro del bloque del dicha estructura se estar\u00e1 repitiendo hasta que se cumpla alguna condici\u00f3n o puede ser infinito; todo esto depende del funcionamiento que necesitemos realizar dentro de este ciclo.</p>"},{"location":"dart/07.loops/#ciclo-for","title":"Ciclo <code>for</code>","text":"<p>El ciclo <code>for</code> tiene el mismo estilo que en <code>C</code>, <code>Java</code>, etc.</p> <p>Tenemos una variable de inicializaron, una comparaci\u00f3n y acci\u00f3n.</p> <p> </p> <p>En este ejemplo vamos a imprimir 10 veces un mensaje.</p> <pre><code>void main() {\n  //mensaje que se repite en 10 ocasiones\n\n  int limite = 10;\n  for (int i = 0; i &lt; limite; i++) {\n    print(\"mensaje que se muestra en el ciclo\");\n  }\n}\n</code></pre>"},{"location":"dart/07.loops/#ciclo-while","title":"Ciclo <code>while</code>","text":"<p>El ciclo <code>while</code> tiene el mismo estilo que en <code>C</code>, <code>Java</code>, etc.</p> <p>Tenemos una variable de inicializaron, una comparaci\u00f3n y acci\u00f3n.</p> <p> </p> <p>En este ejemplo vamos a imprimir 10 veces un mensaje.</p> <pre><code>void main() {\n  //mensaje que se repite en 10 ocasiones\n\n  int contador = 0;\n  int limite = 10;\n  while (contador &lt; limite) {\n    print(\"mensaje que se muestra en el ciclo\");\n    contador++;\n  }\n}\n</code></pre>"},{"location":"dart/07.loops/#ciclos-infinitos","title":"Ciclos infinitos","text":"<p>Los ciclos infinitos como su nombre lo indica, nunca terminan; es decir, no tiene una comparaci\u00f3n que haga que al ser evaluado indique la condici\u00f3n <code>false</code>, lo que har\u00eda que el ciclo termine. Obviamente existen formas de que terminen de alguna manera, como se vera con <code>break</code>.</p> <p>Formato del ciclo infinito <code>for</code></p> <pre><code>for(;;){\n    //lo que este dentro se repetir\u00e1 de manera infinita\n}\n</code></pre> <p>Formato del ciclo infinito <code>while</code></p> <pre><code>// tambi\u00e9n conocido como while-true\n\nwhile(true){\n    //lo que este dentro se repetir\u00e1 de manera infinita\n}\n</code></pre>"},{"location":"dart/07.loops/#continue-y-break","title":"<code>continue</code> y <code>break</code>","text":"<p>Estas palabras reservadas son especiales, por llamarlas de alguna forma. La aplicaci\u00f3n va en funci\u00f3n nuestras necesidades.</p> <ul> <li><code>continue</code>: Nos sirve para que reinicie el ciclo; es decir, dentro del ciclo lo encuentra, el resto de condigo que este debajo ya no se ejecutara, haciendo que el ciclo vuelva a comenzar.</li> <li><code>break</code>: Lo que hace esta palabra reservada es termina con el ciclo, sin mas. No importa si el ciclo esta comenzando o donde vaya, simplemente se termina. Esta es una de las maneras mas habituales de terminar un ciclo infinito.</li> </ul> <pre><code>void main() {\n  int limite = 10;\n  for (int i = 0; i &lt; limite; i++) {\n    if (i % 2 == 0) {\n      continue; //cuando i sea par, no se har\u00e1 la impresi\u00f3n del mensaje\n    }\n    print(\"$i -&gt; mensaje que se muestra en el ciclo\");\n  }\n}\n</code></pre> <pre><code>void main() {\n  int contador = 0;\n  int limite = 10;\n  while (contador &lt; limite) {\n    print(\"$contador -&gt; mensaje que se muestra en el ciclo\");\n    contador++;\n\n    if (contador == 4) {\n      break;// cuando el contador sea 4, el ciclo termina en ese momento\n    }\n  }\n}\n</code></pre>"},{"location":"dart/07.loops/#ejemplos","title":"Ejemplos","text":"<ul> <li>Imprimir 5 veces la palabra \"Hola\"</li> <li>Imprimir del 0 al 50</li> <li>Hacer una calculadora de 2 n\u00fameros, que tenga la opci\u00f3n de sumar, restar y salir, si da una opci\u00f3n que no esta, volver a mostrar el menu inicial, el usuario solo podr\u00e1 salir si elije la opci\u00f3n de salir. Cada que termina de hacer la operaci\u00f3n de sumar o restar, volver a mostrar el men\u00fa</li> <li>Imprimir la tabla de multiplicar del 3, del 1 al 10</li> </ul>"},{"location":"dart/07.loops/#ejercicios-realizarlo-con-for-y-while","title":"Ejercicios (Realizarlo con <code>for</code> y <code>while</code>)","text":"<ul> <li>Realizar un programa para visualizar la tabla de multiplicar que desee el usuario, el usuario dar\u00e1 el valor para la tabla, tambi\u00e9n debe dar el limite donde comienza hasta donde termina, es decir, por ejemplo si da el numero 5, comenzando desde el 3 hasta el 25, comenzara la tabla 5x3 = 15 ... 5x25=125</li> <li>Leer 10 n\u00fameros enteros, solicitando uno a uno al usuario, e imprimir al final cu\u00e1ntos fueron par y cu\u00e1ntos impar.</li> <li>Calcular el factorial de un n\u00famero entero. Se le solicita al usuario que ingrese un n\u00famero entero el cu\u00e1l quiere calcular el factorial del mismo. Ejemplo: 5! = 120</li> <li>Calcular la potencia de un n\u00famero, solicita al usuario el n\u00famero que desea elevar y despu\u00e9s la base a la cu\u00e1l lo elevara. Ejemplo: 2^2= 4, 2^3=8. No se permite el uso de la librer\u00eda matem\u00e1tica.</li> <li>Leer 10 n\u00fameros, solicitando uno a uno al usuario, y al final se imprime por pantalla el n\u00famero m\u00e1s alto ingresado de los 10.</li> <li>Calculadora de la segunda ley de newton. Sale el men\u00fa indicando que desea calcular y la opci\u00f3n de salir. Despu\u00e9s solicita al usuario los valores que conoce e imprimir el resultado, una vez termina de hacer todas las operaciones, debe regresar al men\u00fa inicial, debe existir una opci\u00f3n para terminal el programa, en caso que coloque una opci\u00f3n no existen, debe volver a mostrar el mensaje.</li> <li>C\u00e1lculo de la media de un conjunto de datos. Se le pregunta al usuario cuantos n\u00fameros son, comienza a pedirlos uno a uno y al final imprime el resultado de la media de todos los datos.</li> <li>C\u00e1lculo de la media de un conjunto de datos positivos. En cada iteraci\u00f3n pregunta al usuario si quiere terminar para conocer el resultado o ingresar otro valor, debe dar el valor de -1 para terminar la solicitud de valores. Cuando elija terminar, imprimir el valor total del promedio o media.</li> <li>Realizar una calculadora de ley de Ohm, al inicio te da el menu para seleccionar que se desea calcular; para terminar el programa se debe dar la opci\u00f3n de salida, si no el programa sigue mostrando el menu inicial, si el usuario ingresa un valor y \"no existe en el menu\", manda mensaje que la opci\u00f3n no existe y vuelve a mostrar el menu. El resultado lo debe lanzar en el mejor formato, es decir, si el resultado es 1,000 ohms, en pantalla debe salir 1k, si es posible agregar el s\u00edmbolo de Omega (\\(\\Omega\\)) para resistencias. Si el resultado es 0.005A en pantalla debe salir 5mA. El usuario puede ingresar el valor a como se esta acostumbrado, es decir, el valor que ingresa es 5mA e internamente se obtenga el valor de 0.05 y se pueda realizar el calculo correspondiente</li> <li> <p>Una pasteler\u00eda nos solicita realizar un programa para una maquina de pastelitos, las opciones son las siguientes</p> <p></p> <ul> <li>Debe ir sumando las opciones que elije que elija el usuario. Pero cada vez que termine de elegir, debe volver a mostrar el men\u00fa, hasta que el usuario elija terminar debe imprimir la cantidad total a pagar. El usuario en cualquier momento puede terminar la orden y la maquina debe darle la cantidad a pagar.</li> <li>Por ejemplo, al inicio muestra el menu de pastel, cupcake y salir. Si elije, pastel, ahora le muestra las opciones de chocolate, vainilla, natural y salir, el usuario elije vainilla, y por ultimo elije chispas, debe preguntar si a\u00f1ade algo mas, si es asi, vuelve a mostrar el menu inicial. En caso que elija que ya termino, debe imprimir la cantidad que debe pagar, es decir, (5+1+0.5) \"Cantidad a pagar $6.5\".</li> <li>Recuerda el usuario puede salir en cualquier momento y debe recibir la cantidad que debe pagar.</li> <li>Debe imprimir en forma de lista todo lo solicitado (tu le puedes dar mas formato o mejor presentaci\u00f3n), ejemplo:<ul> <li>2 Pasteles de chocolate con chistas $15.00</li> <li>1 cupcake de chocolate con chispas $5.50</li> <li>Total a pagar: $20.50</li> </ul> </li> </ul> </li> </ul>"},{"location":"dart/08.declaracion_dinamica/","title":"Otra forma de declarar variables","text":"<p>Pues que <code>dart</code> puede compilar para diversas plataformas y la versatilidad del lenguaje, ademas de que es un lenguaje bastante reciente, pues han tomado lo mejor de otros lenguajes, para que <code>dart</code> lo tenga de manera nativa, o que si vienes de otros lenguajes se te haga mas familiar o f\u00e1cil (eso creo yo). Contamos con unas palabras reservadas con caracter\u00edsticas especiales como son las que veremos a continuaci\u00f3n.</p>"},{"location":"dart/08.declaracion_dinamica/#var","title":"<code>var</code>","text":"<p>La palabra reservada <code>var</code> se usa para declarar una variable, y de manera autom\u00e1tica al momento de darle su valor, esta infiere el tipo de esta variable. Como lo podemos ver el siguiente c\u00f3digo:</p> <pre><code>void main() {\n  var var1 = 3; // al recibir un int, ya sabe el compilador el tipo de dato que maneja\n  var var2 = \"Hola\"; // al recibir un String, ya sabe el compilador el tipo de dato que maneja\n\n  print(var1);\n  print(var2);\n}\n</code></pre> <p>Cuando no sepamos que tipo de variable u objeto vamos a ocupar podemos usar <code>var</code>; sin embargo, siempre se recomienda escribir el tipo desde un inicio. En ocasiones por comodidad, flexibilidad, rapidez hacemos uso de <code>var</code>. Por ejemplo, es como manejar <code>let</code> en JavaScript.</p>"},{"location":"dart/08.declaracion_dinamica/#dynamic","title":"<code>dynamic</code>","text":"<p>La palabra reservada <code>dynamic</code> se usa cuando no sabemos nada del tipo de variable que se va a contener o cuando queremos que no tenga un tipo definido, en otras palabras es un objeto gen\u00e9rico, pero que en cada momento que se le asigne un valor, se infiere el tipo pero, este puede cambiar cada vez que queramos. No se recomienda en general que se ocupe, pero en ocasiones es como usarlo, pero no se debe abusar de su uso. El uso mas com\u00fan es cuando tenemos respuestas de una API.</p> <pre><code>void main() {\n  dynamic variable = 3; //inicia siendo un entero\n  print(variable);\n\n  variable = \"Hola\"; //cambio a un string\n  print(variable);\n\n  variable = 2.5; //cambio a un double\n  print(variable);\n}\n</code></pre>"},{"location":"dart/08.declaracion_dinamica/#const-vs-final","title":"<code>const</code> vs <code>final</code>","text":"<p>En esencia b\u00e1sica ambas palabras hacen lo mismo, pero operan en distinto momento.</p> <p>const</p> <p>Generara objetos o variables inmutables. Todo esto antes de compilaci\u00f3n. Por ende, se define el tama\u00f1o en memoria que tendr\u00e1 en toda la vida del programa.</p> <p>Una vez se declara una variable <code>const</code> ya no se puede modificar de ninguna manera.</p> <p>Esto lo hacemos cuando no queremos o no necesitamos que se le modifique su valor, esto es conveniente para que el programa sepa la memoria que necesita para dicha variable.</p> <p>Todo este proceso antes de compilaci\u00f3n.</p> <pre><code>const bar = 1000000; // Unit of pressure (dynes/cm2)\nconst double atm = 1.01325 * bar; // Standard atmosphere\n\n\nvar foo = const [];\nfinal bar = const [];\nconst baz = []; // Equivalent to `const []`\n</code></pre> <p>final</p> <p>A final variable can be set only once  Una variable puede solo ser una vez asignada y nunca mas podr\u00e1 cambiar  Esto sucede en ejecuci\u00f3n.</p> <pre><code>final name = 'Bob'; // Without a type annotation\nfinal String nickname = 'Bobby';\n\nname = 'Alice'; // Error: a final variable can only be set once.\n</code></pre> <p>Mas informaci\u00f3n en https://dart.dev/language/variables#final-and-const</p>"},{"location":"dart/09.colecciones/","title":"Colecciones","text":"<p>Las colecciones son estructuras de datos que nos sirven para almacenar informaci\u00f3n, manipularla y hacer diversas acciones. Tal como agregar, actualizar, borrar.</p>"},{"location":"dart/09.colecciones/#listas-arrays","title":"Listas (Arrays)","text":"<p>Las listas son una estructura de datos muy ocupadas para almacenar informaci\u00f3n en memoria.</p>"},{"location":"dart/09.colecciones/#caracteristicas-de-las-listas-arrays","title":"Caracter\u00edsticas de las listas (arrays)","text":"<ul> <li>Los datos se almacenan uno al lado del otro</li> <li>El indice (index) comienza en 0.</li> <li>Se declara con corchetes cuadrados (<code>[ ]</code>)</li> <li>Los elementos se separan por coma (<code>,</code>).</li> <li>Dentro del operador diamante (<code>&lt;&gt;</code>) se coloca el tipo de objeto que contendr\u00e1 la lista.</li> <li>Puede almacenar un solo tipo de objeto. (Con <code>dynamic</code> todo puede pasar)</li> </ul> <p>Warning</p> <p>La longitud de la lista NO es lo mismo que el ultimo indice de la misma.</p>"},{"location":"dart/09.colecciones/#declaracion-de-una-lista","title":"Declaraci\u00f3n de una lista","text":"<p>Una convenci\u00f3n para darle nombre a una lista es que este sea en plural, ya que si vemos el nombre, en autom\u00e1tico sabemos que se trata de una lista.</p> <pre><code>List&lt;tipo&gt; nombreVariableEnPlural = &lt;tipo&gt; [ valor1, valor2, ... ];\n\n// con var sabemos que infiere el tipo de manera autom\u00e1tica, en ocasiones es mas conveniente definir el tipo de objeto\nvar lista = [elemento1, elemento2, ...];\n</code></pre> <pre><code>//Forma larga, completa indicando todos los detalles\n  List&lt;int&gt; numbers = &lt;int&gt;[1,4,23,5,2,54,56,34,];\n\n  // Forma corta y r\u00e1pida\n  var list = [ 1,4,23,5,2,54,56,34,];\n</code></pre> <p>Operador diamante <code>&lt;&gt;</code></p> <p>Colocando los s\u00edmbolos de menor y mayor que (<code>&lt;&gt;</code>), se conoce como operador diamante (esto viene de JAVA). Dentro de el se coloca el tipo de dato que contendr\u00e1 la lista a crear.</p>"},{"location":"dart/09.colecciones/#obteniendo-datos-individuales-de-una-lista","title":"Obteniendo datos individuales de una lista","text":"<p>Una vez tenemos una lista, la forma de extraer los elementos es por su indice; es decir, indicamos su posici\u00f3n y se asigna a una variable. Esto se realiza colocando dentro de los corchetes cuadrados (<code>[]</code>);</p> <pre><code>void main() {\n  List&lt;int&gt; numbers = &lt;int&gt;[1,4,23,5,];\n\n  int value1 = numbers[0];\n  int value2 = numbers[1];\n  int value3 = numbers[2];\n  int value4 = numbers[3];\n\n  print(value1);    // 1\n  print(value2);    // 4\n  print(value3);    // 23\n  print(value4);    // 5\n}\n</code></pre>"},{"location":"dart/09.colecciones/#recorriendo-una-lista","title":"Recorriendo una lista","text":"<p>Normalmente necesitamos conocer todos los elementos de una lista, y esto lo hacemos con un ciclo.</p> <p>Note</p> <p>Todo es un objeto, por lo tanto, la lista tiene campos y acciones. Entonces, la propia lista sabe cuantos elementos contiene, eso lo haces a traves de su campo <code>length</code>;</p> <pre><code>void main() {\n    List&lt;int&gt; numbers = &lt;int&gt;[1,4,23,5,];\n\n    for(int i = 0; i &lt; numbers.length; i++){\n        int value = numbers[i];\n        print(value);\n    }\n}\n</code></pre>"},{"location":"dart/09.colecciones/#agregando-elementos-a-una-lista","title":"Agregando elementos a una lista","text":"<p>El m\u00e9todo para agregar elementos a una lista es con su propiedad <code>add()</code>.</p> <pre><code>void main() {\n    List&lt;int&gt; numbers = &lt;int&gt;[1,4,23,5,];\n    numbers.add(9);\n    numbers.add(20);\n\n    print(numbers);\n}\n</code></pre> <p>Tambi\u00e9n podemos agregar una lista a otra lista</p> <pre><code>void main() {\n    List&lt;int&gt; numbers = &lt;int&gt;[1,4,23,5,];\n    List&lt;int&gt; numbers2 = &lt;int&gt;[23,53,2,6,8];\n\n    numbers.addAll(numbers2);// agregando una lista a otra.\n\n    print(numbers);\n}\n</code></pre>"},{"location":"dart/09.colecciones/#removiendo-elementos-de-una-lista","title":"Removiendo elementos de una lista","text":"<p>Tenemos dos maneras de remover elementos:</p> <ul> <li>Por posici\u00f3n</li> <li>Por coincidencia (si hay varios repetidos, remueve el primero que encuentra)</li> </ul> <pre><code>void main() {\n    List&lt;int&gt; numbers = &lt;int&gt;[1,4,23,5,];\n\n    numbers.remove(23); // eliminara el numero 23\n\n    print(numbers);\n}\n</code></pre> <pre><code>void main() {\n    List&lt;int&gt; numbers = &lt;int&gt;[1,4,23,5,];\n\n    numbers.removeAt(1); // eliminara el numero 4, porque esta en la posici\u00f3n 1\n\n    print(numbers);\n}\n</code></pre> <p>Note</p> <p>En <code>dart</code> la lista tienen campos y m\u00e9todos directos para obtener el primero y ultimo elemento de la lista y el remover el ultimo; sin necesidad de colocar indices.</p> <ul> <li><code>list.first;</code></li> <li><code>list.last;</code></li> <li><code>lista.removeLast();</code></li> </ul> <p>En ocasiones podemos desear limpiar la lista completa, para esto usamos su m\u00e9todo <code>clear()</code>.</p> <pre><code>void main() {\n    List&lt;int&gt; numbers = &lt;int&gt;[1,4,23,5,];\n\n    numbers.clear();\n\n    print(numbers);\n}\n</code></pre> <p>Conocer mas detalles de la API de dart con relaci\u00f3n a listas en https://api.dart.dev/stable/3.2.4/dart-core/List-class.html</p>"},{"location":"dart/09.colecciones/#sets","title":"Sets","text":"<p>Las listas son una estructura de datos muy ocupadas para almacenar informaci\u00f3n que debe ser \u00fanica; es decir, no se repite.</p>"},{"location":"dart/09.colecciones/#caracteristicas-de-las-listas-tipo-set","title":"Caracter\u00edsticas de las listas tipo SET","text":"<ul> <li>No puede contener elementos repetidos.</li> <li>El indice (index) comienza en 0.</li> <li>Se declara con llaves (<code>{ }</code>)</li> <li>Los elementos se separan por coma (<code>,</code>).</li> <li>Dentro del operador diamante (<code>&lt;&gt;</code>) se coloca el tipo de objeto que contendr\u00e1 la lista.</li> <li>Puede almacenar un solo tipo de objeto. (Con <code>dynamic</code> todo puede pasar)</li> </ul> <p>Una convenci\u00f3n para darle nombre a las listas es que este sea en plural, ya que si vemos el nombre, en autom\u00e1tico sabemos que se trata de una lista.</p>"},{"location":"dart/09.colecciones/#declaracion-de-una-lista-tipo-set","title":"Declaraci\u00f3n de una lista tipo SET","text":"<pre><code>Set&lt;tipo&gt; nombreVariableEnPlural = &lt;tipo&gt; { valor1, valor2, ... };\n\n// con var sabemos que infiere el tipo de manera autom\u00e1tica, en ocasiones es mas conveniente definir el tipo de objeto\nvar nombreVariableEnPlural = { elemento1, elemento2, ...};\n</code></pre> <pre><code>//Forma larga, completa indicando todos los detalles\n  Set&lt;int&gt; numbers = &lt;int&gt;{1,4,23, 1, 5,2,54,56,34,};  // Resultado: {1, 4, 23, 5, 2, 54, 56, 34}\n\n  // Forma corta y r\u00e1pida\n  var list = {1,4,23, 1, 5,2,54,56,34,}; // Resultado: {1, 4, 23, 5, 2, 54, 56, 34}\n</code></pre>"},{"location":"dart/09.colecciones/#mapas-maps-pendiente","title":"Mapas (<code>Maps</code>) (Pendiente)","text":"<p>Son estructura de datos tipos llave-valor, la llave debe ser \u00fanica, valor puede se puede repetir sin ning\u00fan problema. Tambien conocidos como <code>diccionarios</code> o <code>hash</code>.</p>"},{"location":"dart/09.colecciones/#caracteristicas-de-los-maps","title":"Caracter\u00edsticas de los <code>Maps</code>","text":"<ul> <li>La llave es \u00fanica.</li> <li>Se declara indicando el tipo de llave y el tipo de valor que contendr\u00e1 (<code>&lt; tipoX, tipoY &gt; { }</code>)</li> <li>Los pares se separan por coma (<code>,</code>).</li> <li>Dentro del operador diamante (<code>&lt;tipoX, tipoY&gt;</code>) se coloca el tipo de objeto de llave que se usara (es \u00fanica), el tipo de valor tendr\u00e1 asociado.</li> <li>Puede almacenar un solo tipo de objeto. (Con <code>dynamic</code> todo puede pasar)</li> <li>Se usa dos puntos (<code>:</code>), para asociar la llave y su valor; es decir, <code>llave : valor</code>.</li> </ul>"},{"location":"dart/09.colecciones/#declaracion-de-un-map","title":"Declaraci\u00f3n de un <code>Map</code>","text":"<p>Tambi\u00e9n se maneja la convecino del nombre de variable en plural.</p> <pre><code>// Por inferencia de tipo se vuelve muy c\u00f3moda la declaraci\u00f3n de Maps\n\n// Declarando con informaci\u00f3n, se infiere el tipo\nvar hawaiianBeaches = {\n   // llave   :  valor\n  'Oahu': ['Waikiki', 'Kailua', 'Waimanalo'],\n  'Big Island': ['Wailea Bay', 'Pololu Beach'],\n  'Kauai': ['Hanalei', 'Poipu']\n};\n\n// Map a partir de su constructor\nvar searchTerms = Map(); // al no tener los tipos, sera autom\u00e1ticamente &lt;dynamic, dynamic&gt;\n\n// Se indican los tipos de la llave y valor que contendr\u00e1 el mapa/ maps vac\u00edos\nvar nobleGases = Map&lt;int, String&gt;();\nMap&lt;int, String&gt; nobleGases = &lt;int,String&gt;{};\n</code></pre>"},{"location":"dart/09.colecciones/#agregando-valores-a-un-map","title":"Agregando valores a un Map","text":""},{"location":"dart/09.colecciones/#obteniendo-informacion-de-un-map","title":"Obteniendo informaci\u00f3n de un Map","text":"<ul> <li>Obtener por su llave</li> <li>Recorriendo el mapa</li> <li>Obtener por su llave</li> </ul>"},{"location":"dart/09.colecciones/#removiendo-elementos-de-un-map","title":"Removiendo elementos de un Map","text":""},{"location":"dart/09.colecciones/#spread-operator","title":"Spread operator","text":"<p>Mas informaci\u00f3n de colecciones en https://dart.dev/language/collections</p>"},{"location":"dart/10.null/","title":"Null safety","text":"<p>El lenguaje Dart se asegura ser un lenguaje <code>null safety</code>.</p> <p><code>Null safety</code> evita errores que resultan del acceso involuntario a variables establecidas como nulas (<code>null</code>).</p> <p>Con esto, todas las variables requieren un valor. Esto significa que Dart considera todas las variables no-nulas (<code>non-nullable</code>).</p> <p>Para poder declarar variables nulas se debe agregar un signo de pregunta <code>?</code>, despu\u00e9s la notaci\u00f3n del tipo; es decir, <code>tipo? nombreVariable</code>. Esto especifica que el tipo puede contener nulo o alg\u00fan valor.</p> <p>Contando con esta propiedad Dar analiza previo a la compilaci\u00f3n si alg\u00fan valor es nulo y evita que se compile. a menos que se haya indicado el operador <code>?</code>.</p>"},{"location":"dart/10.null/#principios-de-null-safety","title":"Principios de Null safety","text":"<p>Dart supports null safety using the following two core design principles:</p> <p>Dart soporta <code>null safety</code> usando los siguientes dos principios fundamentales de dise\u00f1o.</p> <ul> <li>Todo es <code>non-nullable</code> por default. A menos que expl\u00edcitamente se indique que la variable puede ser nula (<code>null</code>).</li> <li>Puesto que es seguro de nulos, hay optimizaciones en el compilador, y puede llegar a ser mas peque\u00f1os los binarios.</li> </ul>"},{"location":"dart/10.null/#declarando-nulos","title":"Declarando nulos","text":"<p>La forma de declarar cualquier objeto como nulo, es decir, que no tenga referencia a nada es:</p> <pre><code>tipo? nombreVariable = null;\ntipo? nombreVariable;\n\nString? name = null;\nint? age;\n</code></pre> <p>Cuando manejamos variables nulas, debemos siempre esta validando si contiene un valor o no:</p> <pre><code>String? name = null;\n\nif(name == null){\n    print(\"La variable no contiene referencia o valor\");\n}else{\n    print(name);\n}\n</code></pre> <p>En general no se deben manejar variables nulas, pero en ocasiones es necesario.</p> <p>Mas adelante seguiremos aplacando valores nulos.</p> <p>Mas informaci\u00f3n en https://dart.dev/null-safety/understanding-null-safety</p>"},{"location":"dart/11.funciones/","title":"Funciones","text":"<p>Es un bloque de c\u00f3digo que se puede reutilizar y lo podemos llamar la veces que queramos. No repetir c\u00f3digo.</p> <p>Las funciones no sirven para abstraer informaci\u00f3n que no necesita el usuario.</p> <p> </p> <p>Note</p> <p>Las funciones son miembros de \"Primer orden\"; es decir, no necesitan estar dentro de una clase y se pueden asignar a variables.</p> <p>Note</p> <p>Se usa el nombre de \"funci\u00f3n\", cuando NO pertenece a un clase. Como se debe nombrar a un funci\u00f3n, asi como las variables tiene una forma para que sea mas facil nombrarla; las funciones tambi\u00e9n tienen una manera para distinguir si es una variable o una funci\u00f3n.</p> <p>Buenas pr\u00e1cticas</p> <p>Solo debe hacer una sola cosa, y lo que haga lo debe hacer muy bien</p> <p>Note</p> <pre><code>tipoQueDevuelve nombreDeFuncion (tipo argumento1, tipo argumento2, ...){\n    cuerpo de la funci\u00f3n o\n    todas las acciones que ocurren en la funci\u00f3n\n\n    Al final va \"return\" con el dato que devuelve (o referencia)\n}\n</code></pre> <p>Note</p> <p>El nombre de una funci\u00f3n es un verbo (acci\u00f3n)</p> <p>Argumento vs Par\u00e1metro</p> <p>Vamos a usar la palabra argumento y par\u00e1metro como sin\u00f3nimos.</p>"},{"location":"dart/11.funciones/#tipos-de-la-funcion","title":"Tipos de la funci\u00f3n","text":"Palabra reservada Tipo que devuelve <code>void</code> No devuelve nada <code>String</code> Devuelve un tipo String <code>int</code> Devuelve un tipo int <code>double</code> Devuelve un tipo double <code>bool</code> Devuelve un tipo Booleano <code>Object</code> Devuelve ese tipo de \"Objeto\", pr\u00e1cticamente todo en Dart"},{"location":"dart/11.funciones/#como-se-invoca-una-funcion","title":"Como se invoca una funci\u00f3n","text":"<p>De la siguiente manera mandamos a invocar a una funcion, para que realice sus acciones pertinentes.</p> <pre><code>nombreDeFuncion(argumento1, argumento2,...); // Si no retornar nada\ntipo variable = nombreDeFuncion(argumento1, argumento2,...); // en caso que retorne algo guardamos la referencia\n</code></pre>"},{"location":"dart/11.funciones/#funcion-basica-sin-argumento-ni-retornos","title":"Funci\u00f3n b\u00e1sica (sin argumento ni retornos)","text":"<p>Vamos a definir un funci\u00f3n llamada <code>saludo</code>, de tipo <code>void</code>, es decir, que no retorna nada, solo realiza acciones, dentro de ella mandaremos a imprimir unos mensajes. Entre los par\u00e9ntesis no colocamos nada, porque no necesitamos argumentos para que la funci\u00f3n realice sus acciones.</p> <p>Declaramos otra funci\u00f3n, donde usamos el objeto <code>Random</code>, esto es para ver que tambi\u00e9n podemos hacer uso de cualquier librer\u00eda que necesitemos en nuestras funciones. Obviamente, debemos hacer las importaciones necesarias.</p> <p>En la funci\u00f3n <code>main</code> es donde mandamos a llamar a la funci\u00f3n que creamos.</p> funcion1.dart<pre><code>import 'dart:math';\n\nvoid saludo() {\n  print(\"----------\");\n  print(\"Hola\");\n  print(\"----------\");\n}\n\nvoid sumaRandom() {\n  int numero1 = Random().nextInt(100);\n  int numero2 = Random().nextInt(200);\n\n  print(numero1 + numero2);\n}\n\nvoid main(List&lt;String&gt; args) {\n  saludo();\n  saludo();\n  saludo();\n  sumaRandom()\n  sumaRandom()\n}\n</code></pre>"},{"location":"dart/11.funciones/#funcion-basica-con-argumentos","title":"Funci\u00f3n b\u00e1sica (con argumentos)","text":"<p>Vamos a definir 3 funciones recibiendo diferente cantidad de argumentos, pero ninguna retorna algun resultado, dado que son tipo <code>void</code>.</p> funcion2.dart<pre><code>/**\nFunci\u00f3n que recibe un argumento, pero no devuelve nada\n**/\nvoid mensajePersonalizado(String nombre) {\n  print(\"Hola $nombre, Estamos en Dart!!!\");\n}\n\n/**\nFunci\u00f3n que recibe dos argumentos, pero no devuelve nada\n**/\nvoid mensajeEspecialidad(String nombre, String especialidad) {\n  print(\"Hola $nombre, que padre que llevas la especialidad $especialidad\");\n}\n\n/**\nFunci\u00f3n que recibe dos argumentos, pero no devuelve nada\n**/\nvoid mensaje10(String nombre, int edad) {\n  int edadNueva = edad + 10;\n  print(\"Hola $nombre,la edad que tendr\u00e1s en 10 a\u00f1os es $edadNueva\");\n}\n\nvoid main(List&lt;String&gt; args) {\n  mensajePersonalizado(\"Alfredo\");            // invocamos y pasamos el argumento necesario\n  mensajeEspecialidad(\"Ethan\", \"Sistemas\"); // invocamos y pasamos los argumentos necesarios\n  mensaje10(\"Adrian\", 22);                  // invocamos y pasamos los argumentos necesarios\n}\n</code></pre>"},{"location":"dart/11.funciones/#funcion-con-retorno-de-datos-return","title":"Funci\u00f3n con retorno de datos (<code>return</code>)","text":"<p>Vamos a conocer otra palabra reservada, llamada <code>return</code>, esta palabra solo se usa dentro de funciones, y es lo ultimo que ejecuta la funci\u00f3n, devolviendo lo que hallamos puesto que devolver\u00e1 la funci\u00f3n.</p> <p>Cuando vamos a definir que retorna alguna referencia, se debe colocar precediendo al nombre de la funci\u00f3n.</p> funcion3.dart<pre><code>import 'dart:math';\n\n/*\nEsta funci\u00f3n recibe 2 argumentos de tipo double, vamos a sumar estos par\u00e1metros y devolvemos este resultado, que es un double\n*/\ndouble suma(double numero1, double numero2) {\n    double resultado = numero1 + numero2;\n    return resultado;\n}\n\nvoid main(List&lt;String&gt; args) {\n    double sumatoria = suma(Random().nextDouble() * 100, 4);\n    print(\"La suma es $sumatoria\");\n}\n</code></pre>"},{"location":"dart/11.funciones/#pasando-y-devolviendo-parametros-nulos","title":"Pasando y devolviendo par\u00e1metros nulos","text":"<p>En ocasiones podemos necesitar algunos par\u00e1metros en la funcion, esto dependiendo de lo que se necesite realizar dentro de la funcion, por lo tanto podemos manejar par\u00e1metros nulos. Se tiene que hacer la validaci\u00f3n para usar el par\u00e1metro o no.</p> <pre><code>void mensajePersonalizado(String nombre, int? edad){\n    if(edad != null){\n      print(\"Hola $nombre, es un gusto que tengas $edad anos de edad\");\n    }else{\n      print(\"Mucho gusto $nombre\");\n    }\n}\n\n\nvoid main(){\n\n  mensajePersonalizado(\"Alejandro\");\n  mensajePersonalizado(\"Carlos\", 22);\n\n}\n</code></pre> <p>En ocasiones tambi\u00e9n queremos devolver un valor nulo, por lo tanto, asi se define el tipo que se devuelve y que puede ser nulo.</p> <pre><code>String? mensaje(String? nombre){\n    if(nombre == null){\n        return null;\n    }else{\n        return \"Hola $nombre!!!\";\n    }\n}\n\n\nvoid main(){\n\n    String? valor1 = mensaje(null);\n    String? valor2 = mensaje(\"Manuel\");\n\n    print(valor1);\n    print(valor2);\n}\n</code></pre>"},{"location":"dart/11.funciones/#parametros-opcionales","title":"Par\u00e1metros opcionales (<code>[ ]</code>)","text":"<p>En ocasiones por alguna raz\u00f3n, queremos par\u00e1metros opcionales que dependiendo si los pasaron haremos una cosa diferente a lo habitual, esto se puede lograr colocando corchetes cuadrados <code>[]</code> y ahi colocar todos los argumentos que queramos, estos deben ser definidos como tipo nulo, porque al ser opcionales pues por l\u00f3gica deben ser as\u00ed. Porque de lo contrario forzosamente deber\u00edamos pasarlos.</p> <p>Posici\u00f3n de par\u00e1metros opcionales</p> <p>Siempre deben ir al final de los par\u00e1metros que recibe la funcion.</p> <pre><code>import 'dart:math';\n\n/**\n * Si solo me pasan la base, devuelve el cuadrado del numero,\n * si me pasan la potencia, la base se elevara a esa potencia\n */\nint potencia(int base, [int? potencia]){\n\n    if(potencia == null){\n        return pow(base,2).toInt();\n    }\n\n    return pow(base, potencia).toInt();\n}\n\n\nvoid main(){\n    int valor1 = potencia(2);\n    int valor2 = potencia(3,2);\n\n    print(valor1);\n    print(valor2);\n}\n</code></pre>"},{"location":"dart/11.funciones/#valores-por-default","title":"Valores por default","text":"<p>Tambi\u00e9n estos valores opcionales pueden tener valores por default, en caso que necesitemos hacer modificaciones, lo podemos hacer al pasar los par\u00e1metros a la funcion. En esta occasion al tener un valor, pues ya no es necesario maneja nulo en la declaraci\u00f3n del par\u00e1metro.</p> <pre><code>import 'dart:math';\n\n/**\n * Si no me pasan la potencia, por default devuelve el cuadrado de la base\n */\nint potencia(int base, [int potencia = 2]){\n    return pow(base, potencia).toInt();\n}\n\nvoid main(){\n    int valor1 = potencia(2);\n    int valor2 = potencia(3,2);\n\n    print(valor1);\n    print(valor2);\n}\n</code></pre>"},{"location":"dart/11.funciones/#parametros-nombrados","title":"Par\u00e1metros nombrados (<code>{ }</code>)","text":"<p>Dart permite tener par\u00e1metros nombrados en las funciones, haciendo mucho mas claro el par\u00e1metro con su valor. La sintaxis para indicar esto, es con llaves <code>{}</code>; sin embargo, habitualmente hay que darle valores por default, o sino se deben aceptar nulos.</p> <pre><code>double calcularDistancia({double velocidad = 1, double tiempo = 1}) {\n    double distancia = velocidad / tiempo;\n    return distancia;\n}\n\nvoid main() {\n    double distancia = calcularDistancia(velocidad: 10, tiempo: 3);\n    print(\"La distancia es $distancia metros\");\n}\n</code></pre> <p>Se pueden combinar los par\u00e1metros habituales con los nombrados:</p> <pre><code>/**\n * Se pasa un par\u00e1metro sin nombrar y otro nombrado con un valor por default\n */\ndouble calcularFuerza(double masa, {double aceleracion = 9.8}) {\n  return masa * aceleracion;\n}\n\nvoid main() {\n\n    double fuerza = calcularFuerza(10, aceleracion: 1.62); //gravedad (aceleraci\u00f3n) de la luna\n    print(\"La fuerza de una masa de 10kg en la luna es de $fuerza\");\n}\n</code></pre>"},{"location":"dart/11.funciones/#parametros-requeridos-required","title":"Par\u00e1metros requeridos (<code>required</code>)","text":"<p>En ocasiones queremos usar par\u00e1metros nombrados pero, que no contengan un valor por default, sino que el usuario los pase al momento de usar la funcion; para esto existe una palabra reservada <code>required</code> ante puesta al tipo del argumento:</p> <pre><code>/**\n * El primer par\u00e1metro es nombrado y se debe pasar, el segundo es nombrado y opcional, pero contiene un valor por default\n */\ndouble calcularFuerza({required  masa, double aceleracion = 9.8}) {\n    return masa * aceleracion;\n}\n\nvoid main() {\n    double fuerza = calcularFuerza(masa: 10, aceleracion: 1.62); //gravedad (aceleraci\u00f3n) de la luna\n    print(\"La fuerza de una masa de 10kg en la luna es de $fuerza\");\n}\n</code></pre>"},{"location":"dart/11.funciones/#funcion-anonima","title":"Funci\u00f3n an\u00f3nima","text":"<p>Las funciones al ser miembros de primera clase, se pueden asignar a variables; es decir, tenemos el objeto tipo <code>Function</code>, el cual podemos utilizar para declarar el tipo de la variable.</p> <p>Como el nombre lo indica, se llama an\u00f3nima porque la funcion no tiene nombre, solo se especifican todos sus partes pero, sin nombre de funcion.</p> <pre><code>void main() {\n  /**\n     * FORMA LARGA Y COMPLETA, ESPECIFICANDO CADA ELEMENTO\n     * Declaro una variable tipo Funci\u00f3n, que devuelve un entero y recibe dos par\u00e1metros enteros\n    */\n  int Function(int, int) multiplicar = (int valor1, int valor2) {\n    return valor1 * valor2;\n  };\n\n  /**\n     * FORMA CORTA\n     * Declaro una variable tipo Funci\u00f3n, asignando una funci\u00f3n an\u00f3nima que recibe dos par\u00e1metros doubles yu devuelve un double\n    */\n  Function division = (double valor1, double valor2) {\n    return valor1 / valor2;\n  };\n\n  print(valor);\n  print(valor2);\n}\n</code></pre> <p>La forma mas habitual es pasar funciones como par\u00e1metros, mejor conocidas estas funciones como <code>callbacks</code>.</p> <p><pre><code>void main() {\n  /**\n     * FORMA AN\u00d3NIMA\n     * Paso directamente la funci\u00f3n an\u00f3nima para que realice la operaci\u00f3n, dado que el par\u00e1metro que se recibe es una funci\u00f3n\n    */\n\n  var numeros = [1, 2, 3, 4];\n  numeros.forEach((element) { //estamos en el cuerpo de la funci\u00f3n an\u00f3nima\n    print(\"${element * 2}\"); // se multiplica cada elemento de la lista por 2\n  });\n\n  int valor = multiplicar(4, 3);\n  double valor2 = division(3.2, 4.0);\n}\n</code></pre> Podemos crear una funcion que reciba un callback para que realice cierta acci\u00f3n. Esto es algo com\u00fan con funciones as\u00edncronas.</p> <pre><code>/**\n * Esta funci\u00f3n recibe 2 enteros y un callback, el cual realiza la operaci\u00f3n que se desee realizar\n */\nvoid calcular(int a, int b, int Function(int, int) cb) {\n  int resultado = cb(a, b);\n\n  print(resultado);\n}\n\nvoid main(List&lt;String&gt; args) {\n  calcular(5, 4, (a, b) =&gt; a + b);\n\n  calcular(16, 9, (a, b) =&gt; a - b);\n}\n</code></pre>"},{"location":"dart/11.funciones/#funcion-flecha-arrow","title":"Funci\u00f3n flecha (<code>arrow</code>)","text":"<p>Las funciones flecha son una contracci\u00f3n de una funcion normal, haci\u00e9ndola mas corta y directa; tipo de notaci\u00f3n tienes varias cosas impl\u00edcitas:</p> <ul> <li>Por default solo se realiza una acci\u00f3n, el <code>return</code> esta impl\u00edcito y no lleva sus llaves <code>{}</code></li> <li>Estas funciones pueden ser an\u00f3nimas o no.</li> <li>Por default al tener impl\u00edcito <code>return</code> ya no hay necesidad de definir el tipo de la funcion, de cualquier modo se puede hacer.</li> </ul> <pre><code>/**\n * Funci\u00f3n flecha que no recibe par\u00e1metros, retorna un String\n */\nmensaje() =&gt; \"Hola\";\n\n/**\n * Funci\u00f3n que suma dos n\u00fameros y retorna el resultado\n */\nsuma(int numero1, int numero2) =&gt; numero1 + numero2;\n\n/**\n * Se define el tipo que retorna, y se realiza la acci\u00f3n necesaria\n */\ndouble calculoFuerza({required double masa, double aceleracion = 9.8}) =&gt; masa * aceleracion;\n\nvoid main() {\n    print(mensaje());\n    print(suma(3, 4));\n    print(calculoFuerza(masa: 15.2));\n}\n</code></pre>"},{"location":"dart/11.funciones/#funciones-anidadas-nested-functions","title":"Funciones anidadas (<code>Nested functions</code>)","text":"<p>Las funciones al ser miembros de primera clase, tambi\u00e9n podemos declarar funciones dentro de funciones, tambi\u00e9n llamadas funciones anidadas.</p> <pre><code>bool topLevel = true;\n\nvoid main() {\n  var insideMain = true;\n\n  void myFunction() {\n    var insideFunction = true;\n\n    void nestedFunction() {\n      var insideNestedFunction = true;\n\n      print(topLevel);\n      print(insideMain);\n      print(insideFunction);\n      print(insideNestedFunction);\n    }\n  }\n}\n</code></pre>"},{"location":"dart/11.funciones/#tipado-opcional-de-funciones","title":"Tipado opcional de funciones","text":"<p>Dart tiene la opci\u00f3n de no tipar las funciones, como sabemos tiene inferencia de tipo; por ende, el infiere el tipo que retorna funcion, en cuesti\u00f3n del valor que estemos retornando.</p> <pre><code>// Tipando la funcion, sabemos que debemos retornar el tipo String expl\u00edcitamente\nString mensaje(){\n    return \"Hola;\n}\n\n// Sin tipar debe inferior el tipo que se retorna, al ver que se retornar una suma de enteros, sabra de manera autom\u00e1tica que el tipo que retorna la funcion es int\nsuma(int a, int b){\n    return a + b;\n}\n\n// Al no tener return la funcion, por default sabemos que no devuelve nada; por ende, es tipo void\nmensaje(){  // tipo void\n    print(\"Mensaje nuevo\")\n}\n</code></pre>"},{"location":"dart/11.funciones/#alcance-de-variables-scope","title":"Alcance de variables (Scope)","text":"<p>El <code>scope</code>o alcance de variables esta definido por las llaves <code>{ }</code>, es decir, toda variable envuelta entre un bloque definido por las llaves, es el \u00e1mbito en donde existir\u00e1. Fuera de ese bloque, la variable no existe y no se puede tener acceso.</p> <pre><code>String lenguaje = \"Dart\"; // esta variable esta en un \u00c1MBITO GLOBAL, quien sea dentro del archivo puede llamarla y usarla\n\nmain(){// \u00c1MBITO LOCAL DE LA FUNCI\u00d3N MAIN\n    var lenguajes = [\"Python\", \"Java\", \"JavaScript\", \"Lua\"]; //existe dentro de toda la funci\u00f3n main, fuera de este \u00e1mbito no existe\n\n\n    for(int i = 0; i &lt; lenguajes.length; i++){ // \u00c1MBITO LOCAL DEL CICLO FOR\n        // la variable i, solo existe dentro del for, por lo tanto lo puede ocupar donde quiera mientras sea dentro del ciclo, porque es el mismo scope\n        print(lenguajes[i]);\n\n        if( i == 0){// \u00c1MBITO LOCAL DEL IF\n            String mensaje = \"Python es un excelente lenguaje para aprender\"; //esta variable solo existe dentro del if, fuera de \u00e9l desaparece\n            print(mensaje);\n            print(lenguaje);\n        }//termina el if\n    }// termina el ciclo for\n} // termina la funci\u00f3n main\n</code></pre>"},{"location":"dart/11.funciones/#ejemplos","title":"Ejemplos","text":"<ul> <li>Realizar una funcion que reciba el nombre, y la edad, e imprimir un saludo con el nombre y dici\u00e9ndole cuantos a\u00f1os tendr\u00e1 en 10 a\u00f1os</li> </ul>"},{"location":"dart/11.funciones/#ejercicios","title":"Ejercicios","text":"<ol> <li>hacer una funci\u00f3n que calcule el promedio de 3 calificaciones y retorne el resultado, despu\u00e9s usarlo en el main y mandarlo a la pantalla</li> <li>Hacer 3 funciones, para la ley de ohms, una para calcular resistencia, otra para corriente y otra para voltaje, implementarla en su c\u00f3digo del ejercicio la calculadora de ley de ohm</li> <li>Hacer las funciones para calculo de las figuras geom\u00e9tricas, tanto \"per\u00edmetro\" como del \"\u00e1rea\"<ul> <li>cuadrado</li> <li>rect\u00e1ngulo</li> <li>triangulo</li> <li>circulo</li> <li>despu\u00e9s usarlas para hacer la calculadora de todas estas opciones</li> </ul> </li> </ol> <p>Mas informaci\u00f3n en https://dart.dev/language/functions</p>"},{"location":"dart/12.poo/","title":"Programaci\u00f3n Orientada a Objetos (POO)","text":"<p>La POO es un paradigma de programaci\u00f3n, el cual nos genera el concepto de como visualizar el mundo real y abstraerlo al c\u00f3digo de programaci\u00f3n y aplicarlo al software.</p> <p>Note</p> <p>Una clase es conocida como el esqueleto o plantilla de un objeto, lo que define qu\u00e9 contiene un clase y c\u00f3mo lo va hacer.</p> <p>Note</p> <p>Cuando creamos un objeto a partir de una clase, se dice instancia.</p> <p>Note</p> <p>En Dart todo es un Objeto, eso lo primero que nos tiene que quedar muy claro.</p>"},{"location":"dart/12.poo/#caracteristicas-de-las-clases","title":"Caracter\u00edsticas de las clases","text":"<ul> <li>Puede contener campos y m\u00e9todos.</li> <li>En un archivo se puede contener mas de una clase</li> <li>En archivo pueden existir clases y funciones</li> <li>Lo ideal es por archivo existan solo las clases necesarias</li> <li>Las clases tienen campos (atributos) y m\u00e9todos (comportamientos)</li> <li>Puede contener campos y m\u00e9todos privados</li> <li>Pueden existir campos y m\u00e9todos est\u00e1ticos.</li> <li>Por default los campos y m\u00e9todos son p\u00fablicos.</li> </ul>"},{"location":"dart/12.poo/#definiendo-clases","title":"Definiendo Clases","text":"<pre><code>class NombreClase{\n    // cuerpo de la clase\n}\n</code></pre>"},{"location":"dart/12.poo/#campos","title":"Campos","text":"<ul> <li>Los campos son las propiedades definidas en un clase.</li> <li>Estos por buenas practicas se colocan al principio de la clase.</li> <li>Estas propiedades equivalente a tener variables o constantes globales de la clase.</li> <li>Estas quedan dentro del scope de la propia clase, para que sean manipuladas por los m\u00e9todos, en caso que lo requiera.</li> <li>Los campos globales de una clase pueden ser accedidos por otras clases o funciones que est\u00e9n en el mismo archivo.</li> </ul> <pre><code>class NombreClase{\n\n    // CAMPOS\n    int     campo1 = 3;\n    String  campo2 = \"hola\";\n\n}\n</code></pre>"},{"location":"dart/12.poo/#metodos","title":"M\u00e9todos","text":"<p>Conocimos el termino de funci\u00f3n; sin embargo, cuando hablamos de una clase se dice m\u00e9todo.</p> <ul> <li>Es un comportamiento (acci\u00f3n) que realiza un objeto (cosa).</li> <li>Es un bloque o secuencia de c\u00f3digo que se repite continuamente.</li> <li>Hace una sola tarea, y lo hace muy bien.</li> <li>Su nombre se define con un verbo (acci\u00f3n).</li> <li>Funciones de un objeto.</li> <li>Modifica estados.</li> </ul> <pre><code>class NombreClase{\n    // M\u00c9TODOS\n    /// Definici\u00f3n de un m\u00e9todo\n    String metodo1(){\n        return \"\";\n    }\n\n    int? metodo2(double arg1){\n        return null;\n    }\n}\n</code></pre>"},{"location":"dart/12.poo/#integrando-una-clase","title":"Integrando una clase","text":"<p>Hemos visto las partes b\u00e1sicas de una clase, vamos a crear una completa de ejemplo. Una clase por si sola no hace nada, se debe crear una instancia y usar sus propiedades.</p> <pre><code>class Persona {\n  int dedos = 10;\n  String nombre = \"Mario\";\n\n  void correr() {\n    print(\"Corro!!!!\");\n  }\n\n  void dormir(int horas) {\n    print(\"Duermo por $horas horas\");\n  }\n}\n\nvoid main() {\n  Persona persona1 = Persona(); // Creamos una instancia de la clase Persona\n\n  print(persona1.dedos);\n  print(persona1.nombre);\n\n  persona1.correr();\n  persona1.dormir(28);\n}\n</code></pre>"},{"location":"dart/12.poo/#encapsulamiento-private","title":"Encapsulamiento (<code>private</code>)","text":"<p>Dentro de los conceptos b\u00e1sicos de la POO, tenemos un termino llamado <code>encapsulamiento</code>, ya vimos que cuando definimos campos y m\u00e9todos, y creamos una instancia, podemos acceder a todos ellos; sin embargo, normalmente creamos m\u00e9todos o campos que solo queremos usar dentro de la clase, no exponerlos para que nadie los use. Para esto existe una forma para convertirlos en privado, esto quiere decir que solo pueden ser accedidos solo por miembros de la propia clase.</p> <p>Note</p> <p>Esto lo logramos anteponiendo en el nombre un guion bajo (<code>_</code>)</p> <pre><code>class Estudiante {\n  String _nombre = \"\";\n  String _especialidad = \"\";\n\n  void asignarNombre(String nombre) {\n    _nombre = nombre;\n  }\n\n  String obtenerNombre() {\n    return _nombre;\n  }\n\n  void asignarEspecialidad(String especialidad) {\n    _especialidad = especialidad;\n  }\n\n  String obtenerEspecialidad() {\n    return _especialidad;\n  }\n}\n\nvoid main() {\n  final estudiante = Estudiante();// se crea una instancia final, porque esta no cambiara\n\n  estudiante.asignarNombre(\"Carlos\");\n  estudiante.asignarEspecialidad(\"Sistemas\");\n  print(estudiante.obtenerNombre());\n  print(estudiante.obtenerEspecialidad());\n\n}\n</code></pre>"},{"location":"dart/12.poo/#constructor","title":"Constructor","text":"<p>La funci\u00f3n o m\u00e9todo constructor es lo primero que se manda a llamar cuando creamos un instancia. El constructor se debe llamar igual que la clase.</p>"},{"location":"dart/12.poo/#constructor-vacio","title":"Constructor vaci\u00f3","text":"<p>Por default se crea el constructor vaci\u00f3; es decir, cuando creamos la clase lo escribamos o no, ahi esta. Por eso cuando creamos la instancia se tienen unos par\u00e9ntesis vac\u00edos.</p> <pre><code>class Persona {\n  Persona() {   // m\u00e9todo constructor\n    print(\"El constructor es lo primero que se ejecuta\");\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  Persona();\n}\n</code></pre>"},{"location":"dart/12.poo/#constructor-con-argumentos","title":"Constructor con argumentos","text":"<p>En muchas ocasiones necesitamos que al crear una instancia de un objeto, a este se le deban dar valores por default, para que el objeto realice lo que deba hacer, antes de mandar a llamar a cualquier m\u00e9todo o campo de la clase.</p> <pre><code>class Persona {\n  String _nombre = \"\";\n\n  Persona(String nombre) {\n    _nombre = nombre;\n  }\n\n  void saludo() {\n    print(\"Hola me llamo $_nombre\");\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  final p1 = Persona(\"Carlos\");\n  final p2 = Persona(\"Mario\");\n  final p3 = Persona(\"Ana\");\n\n  p1.saludo();\n  p2.saludo();\n  p3.saludo();\n}\n</code></pre>"},{"location":"dart/12.poo/#this","title":"<code>this</code>","text":"<p>La palabra reservada <code>this</code>  nos ayuda a hacer referencia a la propia clase, sus campos y m\u00e9todos de la misma. Este lo usamos mayormente en el constructor por el modo en podemos llamar los campos para inicializados y el objeto pueda tener la informaci\u00f3n necesaria cuando se genere una instancia. Tambi\u00e9n lo hacemos cuando la variable local de un m\u00e9todo se llama igual al campo de la clase.</p> <pre><code>class Persona {\n  String nombre = \"\";\n  int edad = 0;\n\n  Persona(String nombre, int edad) {\n    this.nombre = nombre;\n    this.edad = edad;\n  }\n\n  void saludo() {\n    print(\"Hola me llamo $nombre\");\n  }\n\n  void decirEdad() {\n    print(\"La edad de ${this.nombre} es ${this.edad}\");\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  final p1 = Persona(\"Carlos\", 29);\n  final p2 = Persona(\"Mario\", 32);\n  final p3 = Persona(\"Ana\", 12);\n\n  p1.saludo();\n  p1.decirEdad();\n  p2.saludo();\n  p2.decirEdad();\n  p3.saludo();\n  p3.decirEdad();\n}\n</code></pre>"},{"location":"dart/12.poo/#constructor-con-parametros-nombrados","title":"Constructor con par\u00e1metros nombrados","text":"<p>Al final el m\u00e9todo constructor es un m\u00e9todo; por ende, de igual manera que cualquier funci\u00f3n puede recibir argumentos nombrados. De la misma forma que lo hacemos en las funciones, podemos tener par\u00e1metros nombrados requeridos y con valores po default.</p> <pre><code>class Persona {\n  String nombre = \"\";\n  int edad = 0;\n\n  Persona({required String nombre, int edad = 0}) {\n    this.nombre = nombre;\n    this.edad = edad;\n  }\n\n  void saludo() {\n    print(\"Hola me llamo $nombre\");\n  }\n\n  void decirEdad() {\n    print(\"La edad de ${this.nombre} es ${this.edad}\");\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  final p1 = Persona(nombre: \"Carlos\", edad: 23);\n\n  p1.saludo();\n  p1.decirEdad();\n}\n</code></pre>"},{"location":"dart/12.poo/#constructor-reducido","title":"Constructor reducido","text":"<p>En ocasiones solo se usa el constructor solo para inicializar los campos de la clase, sin ninguna otra acci\u00f3n; dado esto, con Dart nos da una manera mas corta de hacer.</p> <p>En este primer ejemplo los campos son privados.</p> <pre><code>class Persona {\n  String _nombre = \"\";\n  int _edad = 0;\n\n  Persona(String nombre, int edad) : _nombre = nombre, _edad = edad;\n\n  void saludo() {\n    print(\"Hola me llamo $_nombre\");\n  }\n\n  void decirEdad() {\n    print(\"La edad de ${this._nombre} es ${this._edad}\");\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  final p1 = Persona(\"Mario\", 22);\n\n  p1.saludo();\n  p1.decirEdad();\n}\n</code></pre> <p>En este ejemplo los campos son p\u00fablicos.</p> <pre><code>class Persona {\n  String nombre;\n  int edad;\n\n  Persona(this.nombre, this.edad);\n\n  void saludo() {\n    print(\"Hola me llamo $nombre\");\n  }\n\n  void decirEdad() {\n    print(\"La edad de ${this.nombre} es ${this.edad}\");\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  final p1 = Persona(\"Mario\", 22);\n\n  p1.saludo();\n  p1.decirEdad();\n}\n</code></pre> <p>En este ejemplo tenemos par\u00e1metros nombrados, y como queremos que se inicialicen cuando se genere la instancia, los colocamos como requeridos.</p> <pre><code>class Persona {\n  String nombre;\n  int edad;\n\n  Persona({required this.nombre, required this.edad});\n\n  void saludo() {\n    print(\"Hola me llamo $nombre\");\n  }\n\n  void decirEdad() {\n    print(\"La edad de ${this.nombre} es ${this.edad}\");\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  final p1 = Persona(nombre: \"Mario\", edad: 22);\n\n  p1.saludo();\n  p1.decirEdad();\n}\n</code></pre>"},{"location":"dart/12.poo/#constructor-nombrado","title":"Constructor nombrado","text":"<p>Dart tiene una caracter\u00edstica curiosa con respecto a constructores, podemos personalizar el constructor con otro nombre, al final la finalidad es la misma, ser lo primero que se llama al crear una instancia, pero con nombre diferente.</p> <pre><code>class Persona {\n  String nombre;\n  int edad;\n\n  // constructor \"normal\"\n  Persona({required this.nombre, required this.edad});\n\n  // Este constructor no recibe par\u00e1metros, pero se inicializan, no tiene cuerpo pero se pudiera hacer de la misma forma.\n  Persona.anonima() : nombre = \"an\u00f3nimo\", edad = 0;\n\n  // aqu\u00ed mando a llamar al constructor con par\u00e1metros y paso los datos por default\n  // con this puedo llamar cualquier constructor\n  Persona.joven() : this(nombre: \"joven\", edad: 15);\n\n  void saludo() {\n    print(\"Hola me llamo $nombre\");\n  }\n\n  void decirEdad() {\n    print(\"La edad de ${this.nombre} es ${this.edad}\");\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  final p1 = Persona(nombre: \"Mario\", edad: 22);\n  final p2 = Persona.anonima();\n  final p3 = Persona.joven();\n\n  p1.saludo();\n  p1.decirEdad();\n  p2.saludo();\n  p2.decirEdad();\n  p3.saludo();\n  p3.decirEdad();\n}\n</code></pre>"},{"location":"dart/12.poo/#getters-y-setters","title":"Getters y Setters","text":"<p>De los lenguajes programados a objetos, por ejemplo JAVA, surgi\u00f3 una buena practica para la manipulaci\u00f3n del estado de los campos de una clase, llamados setter y getters, como el nombre lo indica eran para asignar un dato o para obtenerlo respectivamente. Aqu\u00ed se mantiene ese mismo concepto pero, con algunos cambios.</p> <p>Manera tradicional, ya no se usa en Dart</p> <pre><code>class Auto {\n  int _velocidad = 0; //campo privado, que se cambia su valor cuando se crea una instancia\n\n  Auto(int velocidad){\n    this._velocidad = velocidad;\n  }\n\n  void setVelocidad(int velocidad) {\n    this._velocidad = velocidad;\n  }\n\n  int getVelocidad() {\n    return this._velocidad;\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  final Auto auto1 = Auto(100);\n\n  auto1.setVelocidad(50); // asigno el valor\n\n  int velocidad = auto1.getVelocidad(); // obteniendo el valor del campo\n\n  print(\"La velocidad es $velocidad km/h\");\n}\n</code></pre> <p>Si vamos a necesitar generar un m\u00e9todo set y uno get b\u00e1sico, ya no es necesario crearlos, simplemente se hace el campo publico y ya. Siempre y cuando solo sea modificar y obtener el valor, como en el ejemplo tradicional.</p> <pre><code>class Auto {\n\n  int velocidad = 0;\n\n}\n\nvoid main(List&lt;String&gt; args) {\n  final Auto auto1 = Auto();\n  auto1.velocidad = 100; // asigno el valor es equivalente a un set, asignando o cambiando el estado del campo\n\n  int velocidad =\n      auto1.velocidad; // equivalente a un get, obteniendo el valor del campo\n\n  print(\"La velocidad es $velocidad km/h\");\n}\n</code></pre> <p>Sin embargo, si queremos continuar como la manera tradicional, Dart no da una nueva forma con palabras reservadas espec\u00edficamente para este prop\u00f3sito <code>set</code> y <code>get</code>. No es estrictamente necesario usar ambos.</p> <p>Caracter\u00edsticas <code>set</code></p> <ul> <li>Se usa la palabra reservada <code>set</code></li> <li>Se declara como una funci\u00f3n</li> <li>Por default <code>set</code> es como funci\u00f3n void</li> <li>Podemos usar una funci\u00f3n flecha o una funci\u00f3n normal con cuerpo</li> </ul> <p>Caracter\u00edsticas <code>get</code></p> <ul> <li>Se usa la palabra reservada <code>get</code></li> <li>Se declara como una funci\u00f3n, y se antepone el tipo que retorna</li> <li>Por default <code>get</code> debe retornar algo</li> <li>Se usa funci\u00f3n flecha, dado que solo retornar un valor o podemos hacer alg\u00fan cambio en una acci\u00f3n</li> </ul> <pre><code>class Auto {\n  //campo privado, que se cambia su valor cuando se crea una instancia\n  int _velocidad = 0;\n  String _nombre = \"\";\n  int _modelo = 0;\n\n  Auto(String nombre, int velocidad, {required int modelo}) {\n    this._velocidad = velocidad;\n    this._nombre = nombre;\n    _modelo = modelo;\n  }\n\n  set velocidad(int velocidad) =&gt;\n      this._velocidad = velocidad; //podemos usar una funci\u00f3n flecha\n\n  int get velocidad =&gt;\n      this._velocidad; //usamos una funci\u00f3n flecha, no se usan par\u00e9ntesis\n\n  /**\n  * Si necesitamos modificar el valor recibido, en el cuerpo de la funci\u00f3n lo podemos hacer\n  */\n  set nombre(String nombre) {\n    String nuevoNombre = \"Un super $nombre\";\n    _nombre = nuevoNombre;\n  }\n\n  String get nombre =&gt; _nombre;\n\n  // como el campo de modelo no quiero que sea modificado nunca, solo se puede obtener su valor de cuando se crea la instancia\n  int get modelo =&gt; _modelo;\n}\n\nvoid main(List&lt;String&gt; args) {\n  final Auto auto1 = Auto(\"\", 0, modelo: 2004);\n\n  auto1.velocidad = 60; // asigno el valor\n  int velocidad = auto1.velocidad; // obteniendo el valor del campo\n  auto1.nombre = \"Ferrari\";\n  String nombreAuto = auto1.nombre;\n\n  print(\"Este auto es un $nombreAuto\");\n  print(\"La velocidad es $velocidad km/h\");\n  print(\"Es modelo es ${auto1.modelo}\");\n}\n</code></pre>"},{"location":"dart/12.poo/#late","title":"<code>late</code>","text":"<p>Dart nos da un palabra reservada para inicializar campos un poco despu\u00e9s de la inicializaron de una instancia. Esto nos da ciertas libertades y nos ayuda a hacer los campos <code>final</code>. Esto tambi\u00e9n nos permite usar variables que son <code>non-null</code> pero, sin hacer la inicializaci\u00f3n, pues <code>late</code> permite esta acci\u00f3n. <code>late</code> es como un contrato con Dart de decir, \"te prometo que cuando lo llame no sera nulo\". Tambi\u00e9n se le pueden llamar que son campos con inicializaci\u00f3n tard\u00eda. Esto nos ayuda a que si la instancia es muy pesada o tarda mucho tiempo, no haga lento el arranque de la inicializaci\u00f3n de la clase que lo contiene.</p> <p>!!! warning Ten cuidad con <code>late</code>     Si mandamos a llamar una instancia declarada como <code>late</code> y esta sigue siendo <code>null</code>, la culpa es nuestra. Por eso Dart es <code>non-null</code> por default.</p>"},{"location":"dart/12.poo/#sintaxis-de-late","title":"Sintaxis de <code>late</code>","text":"<pre><code>late tipo nombreVariable; // no se asigna nada porque posteriormente se le asigna un valor\n</code></pre> <p>En este ejemplo no tenemos el peligro de caer en un caso nulo.</p> <pre><code>class Persona {\n  late final String _nombre;\n  late final int _edad;\n\n  // Al tener los campos como late, no me obliga darles valores por default en el constructor\n  Persona(String nombre, {required int edad})\n      : _nombre = nombre,\n        _edad = edad;\n\n  String get nombre =&gt; _nombre;\n\n  int get edad =&gt; _edad;\n}\n\nvoid main(List&lt;String&gt; args) {\n  final Persona persona = Persona(\"Carlos\", edad: 10);\n  print(\"${persona.nombre} tiene ${persona.edad} primaveras\");\n}\n</code></pre>"},{"location":"dart/12.poo/#static-pendiente","title":"<code>static</code> (Pendiente)","text":"<p>La palabra reservada <code>static</code> para crear campos y m\u00e9todos dentro de una clase; que pueden ser llamadas sin la necesidad de crear una instancia de una clase.</p> <p>Estructura para usar <code>static</code>, deben estar dentro de una clase:</p> <pre><code>// field\nstatic type nameVariable = value;\n\n// function method\n\nstatic type nameFunction(){\n    // body of methods\n}\n</code></pre> <pre><code>class Math {\n  static double PI_SHORT = 3.1416;\n\n  static String cutNumber(num number) {\n    return number.toStringAsFixed(2);\n  }\n}\n\nvoid main(List&lt;String&gt; args) {\n  print(Math.PI_SHORT);\n  print(Math.cutNumber(25.3636464));\n}\n</code></pre>"},{"location":"dart/12.poo/#ejemplos","title":"Ejemplos","text":"<ul> <li>Crear una clase Auto:<ul> <li>Campos:</li> <li>noPuertas:int</li> <li>color:String</li> <li>M\u00e9todos:</li> <li>acelerar:void</li> <li>arrancar:void</li> <li>cambioColor(String):void</li> </ul> </li> </ul>"},{"location":"dart/12.poo/#ejercicios","title":"Ejercicios","text":"<ul> <li>Crear clase Motor<ul> <li>campos:<ul> <li>voltaje:double</li> <li>tipo:String (DC, AC, etc.)</li> </ul> </li> <li>Comportamientos<ul> <li>arrancar:void -&gt; mensaje que gira</li> <li>cambioGiro(int giro):void -&gt; mandar mensaje de hacia donde esta girando, en funci\u00f3n del giro que pasaron. giro = 1, derecha. giro = 2, izquierda</li> <li>apagar:void -&gt; mensaje de se apago el motor</li> <li>cambiarVoltaje(double voltajeNuevo):double -&gt; retorna el voltaje actual, si el voltaje es 0, se manda a llamar la funci\u00f3n apagar.</li> </ul> </li> </ul> </li> <li>Probar su clase en un m\u00e9todo main</li> <li>Crear la clase SensorTemperatura:<ul> <li>campos<ul> <li>codigoSensor:String</li> <li>voltajeAlimentacion:double</li> </ul> </li> <li>comportamientos<ul> <li>obtenerTemperatura([String]):double -&gt; devuelve un valor random (double), entre 0 a 50\u00b0C. Recibe si quiere el valor en la funci\u00f3n es para si retorna el cent\u00edgrados o Fahrenheit, por default devuelve grados cent\u00edgrados</li> <li>obtenerNombreSensor:String -&gt; devuelve el nombre del sensor</li> <li>cambiarVoltaje(double voltajeNuevo):void -&gt; Si pasan un voltaje superior a 5 o inferior a 0, lanza un mensaje que diga: \"Sensor quemado\", en caso que este en el rango correcto, dice \"sensor funcionando correctamente\"</li> </ul> </li> <li>Probar su clase en un m\u00e9todo main</li> </ul> </li> </ul> <p>Mas informaci\u00f3n en https://dart.dev/language/classes</p>"},{"location":"dart/13.paquete/","title":"Paquetes y librer\u00edas","text":"<p>Los paquetes o librer\u00edas es c\u00f3digo adicional que no ayuda a realizar muchas acciones que no vienen en la API core de Dart, por ejemplo flutter, que es un framework para realizar UI. Nosotros podemos crear librer\u00edas o paquetes nuevos y compartirlos.</p>"},{"location":"dart/13.paquete/#puddev","title":"pud.dev","text":"<p>Es el sitio oficial de donde podemos descargar muchos paquetes para nuestras aplicaciones. Esto los debemos agregar a el archivo <code>pubspec.yaml</code> cuando creamos un proyecto <code>Dart</code>.</p> <p>Ir al sitio oficial pub.dev.</p>"},{"location":"dart/13.paquete/#archivo-de-control-de-dependencias-pubspecyaml","title":"Archivo de control de dependencias <code>pubspec.yaml</code>","text":"<p>El archivo <code>pubspec.yaml</code> nos sirve para gestionar las dependencias (packages) de nuestro proyecto. Ahi podemos manipular las versiones de las librer\u00edas, la version de Dart, dependencias de desarrollo y dependencias de proyecto, la version de nuestra app o librer\u00eda, descripci\u00f3n, nombre del proyecto.</p> <p>Ejemplo del archivo <code>pubspec.yaml</code></p> <pre><code>name: NOMBRE_PROYECTO\ndescription: DESCRIPCI\u00d3N DEL PROYECTO\nversion: 1.0.0\n\nenvironment: ## Version de Dart utilizada en el proyecto\n  sdk: ^3.0.5\n\ndependencies: ## Dependencias del proyecto\n  nombre_paquete: version\n\ndev_dependencies: ## Dependencias de desarrollo, no se compilan en la aplicaci\u00f3n final\n  nombre_paquete: version\n</code></pre> <p>En este archivo colocamos el nombre del paquete y su version, con la ayuda del IDE descarga la dependencia o lo podemos hacer con la herramienta que contiene Dart.</p> <p>Con una opci\u00f3n que trae Dart podemos agregara de manera autom\u00e1tica la dependencia al archivo <code>pubspec.yaml</code>, con la version correspondiente. Esto lo hacemos desde la terminal con el siguiente comando:</p> <pre><code>dart pub add nombre_paquete\n</code></pre>"},{"location":"dart/13.paquete/#importaciones-import","title":"Importaciones (<code>import</code>)","text":"<p>Para agregar el package o librer\u00eda que hemos elegido de pub.dev o alg\u00fan archivo que nosotros mismo hemos creado, lo hacemos con la palabra reservada <code>import</code>, con la siguiente estructura.</p> <pre><code>import 'package:lib/lib.dart'; // estructura general\n</code></pre> <p>Si vamos a importar un archivo que hemos descargado de pub.dev</p> <pre><code>import 'package:lib/archivo.dart'; // estructura general\n</code></pre> <p>Si vamos a agregar un archivo que nosotros mismos hemos realizado y que no esta contenido en un paquete, solo colocamos la ruta relativa.</p> <pre><code>import 'archivo.dart'; // estructura general\n</code></pre> <p>Mas informaci\u00f3n en https://dart.dev/language/libraries</p>"},{"location":"dart/14.errores/","title":"Manejo de errores","text":"<p>Dart puede lanzar Excepciones, que no es mas que lanzar errores cuando no sabe maneja alguna situaci\u00f3n inesperada; esto hace que nuestra aplicaci\u00f3n falle, y debemos tratar esos problemas cuando suceden.</p> <p>La estructura mas general para atrapar una excepci\u00f3n es envolver la parte de c\u00f3digo donde puede suceder el error.</p> <ul> <li>Bloque <code>try</code>: Aqu\u00ed va todo el c\u00f3digo que escribimos habitualmente; es decir, lo que se supone que se debe ejecutar si todo marcha bien.</li> <li>Bloque <code>catch</code>: En esa secci\u00f3n va el c\u00f3digo que se debe ejecutar cuando se genere un error.</li> </ul> <pre><code>try{\n\n    // c\u00f3digo que se ejecuta normalmente\n\n}catch (e) {\n\n    // c\u00f3digo que se ejecuta si en la secci\u00f3n del try se genero un excepci\u00f3n\n    // La variable `e` es el objeto que trae la informaci\u00f3n del error, la podemos usar o no, eso depende de nuestras necesidades\n\n}\n</code></pre>"},{"location":"dart/14.errores/#ejemplo","title":"Ejemplo","text":"<p>Vamos a suponer que queremos acceder a una posicion de una lista que no existe, esto nos da un error de posicion:</p> <pre><code>void main(List&lt;String&gt; args) {\n  var listaNumeros = &lt;int&gt;[1, 2, 3];\n\n  print(listaNumeros[4]);\n}\n</code></pre> <p>Cuando ejecutamos nos lanza una excepci\u00f3n:</p> <pre><code>Unhandled exception:\nRangeError (index): Invalid value: Not in inclusive range 0..2: 4\n#0      List.[] (dart:core-patch/growable_array.dart:264:36)\n#1      main (file:///home/xizuth/Projects/curso_flutter/docs/programs/error.dart:4:21)\n#2      _delayEntrypointInvocation.&lt;anonymous closure&gt; (dart:isolate-patch/isolate_patch.dart:295:33)\n#3      _RawReceivePort._handleMessage (dart:isolate-patch/isolate_patch.dart:184:12)\n</code></pre> <ul> <li>El error nos varia informaci\u00f3n, nos dice de entrada que la excepci\u00f3n no esta siendo manejada o atrapada.</li> <li>Nos dice cual es el error que causo que se disparara la excepci\u00f3n</li> <li>Nos da el stack o la ruta de como fue la propagaci\u00f3n del error.</li> </ul> <p>Vamos a evitar que nos diga ese error, por un mensaje mas amigable</p> <pre><code>void main(List&lt;String&gt; args) {\n  try {\n    var listaNumeros = &lt;int&gt;[1, 2, 3];\n\n    print(listaNumeros[4]);\n\n  } catch (e) {\n    print(\"Se quiso acceder a una posici\u00f3n no posible\");\n  }\n}\n</code></pre> <p>Salida:</p> <pre><code>    Se quiso acceder a una posici\u00f3n no posible\n</code></pre> <p>Mas informaci\u00f3n en https://dart.dev/language/error-handling</p>"},{"location":"dart/15.asincronismo/","title":"As\u00edncronismo","text":"<p>Dart desde concepci\u00f3n ha sido un lenguaje de un solo hilo, pero tiene un stack de ejecuci\u00f3n que permite que sea as\u00edncrono (si vienes de javascript trabaja igual).</p> <p>Es decir, en ocasiones se deben realizar acciones que se pueden tardar un tiempo corto o largo, esto puede variar en funcion de la tarea, pero nuestro flujo de la ampliaci\u00f3n no puede detenerse, este debe continuar. Entonces ahi es donde usamos la programaci\u00f3n as\u00edncrona, significa que la tarea se manda a segundo plano (background) mientras el flujo principal continua, y cuando dicha tarea termina continua con lo que debe hacer. Con todo esto logramos que nuestro programa no se atore y el usuario pueda seguir interactuando con la aplicaci\u00f3n.</p> <p>Tenemos tres maneras de utilizar la programaci\u00f3n as\u00edncrona:</p> <ul> <li>callback: Pasamos una funcion que se conoce como callback, que se ejecuta hasta que la funcion a la cual se le paso termina y le paso los par\u00e1metros que necesita para continuar con su tarea.</li> <li>then con Future: una funcion que se llama para encadenar varios callback, sin la necesidad de caer en el callback hell</li> <li>Async-await con Future: De esta manera es la mas elegante de \"convertir\" nuestro condigo as\u00edncrono en s\u00edncrono; sigue siendo as\u00edncrono pero visualmente se viera s\u00edncrono.</li> </ul> <p>En esta secci\u00f3n se hace uso intensivo de funciones an\u00f3nimas y funciones flechas, esto es lo mas normal y com\u00fan en programaci\u00f3n as\u00edncrona.</p>"},{"location":"dart/15.asincronismo/#callback","title":"Callback","text":"<p>Los callback son la manera mas tradicional de manejar eventos o escuchadores. Un callback es una funci\u00f3n que se pasa a otra funci\u00f3n, por eso le llamamos funci\u00f3n callback o para abreviar <code>cb</code>.</p> <p>Declaramos una funcion que recibe 3 par\u00e1metros, dos valores enteros y una funcion callback, la cual se ejecuta despu\u00e9s de que se realicen ciertas acciones y devuelve la informaci\u00f3n procesada.</p> <pre><code>// programaci\u00f3n as\u00edncrona\nvoid calculo(int a, int b, void Function(int a, int b) callback) {\n  print(\"el primer valor es $a\");\n  print(\"el primer valor es $b\");\n  int doble1 = a * 2;\n  int doble2 = b * 2;\n\n  callback(doble1, doble2);\n}\n\nvoid main(List&lt;String&gt; args) {\n  calculo(5, 2, (a, b) {\n    print(\"suma ${a + b}\");\n  });\n  calculo(5, 2, (a, b) {\n    print(\"resta ${a - b}\");\n  });\n  calculo(5, 2, (a, b) {\n    print(\"multi ${a * b}\");\n  });\n  calculo(5, 2, (a, b) {\n    print(\"divide ${a / b}\");\n  });\n}\n</code></pre> <p>La formas mas com\u00fan y usual es cuando usamos la funcion <code>forEach</code> de las colecciones, para recorrer el array y realizar una acci\u00f3n.</p> <pre><code>main(List&lt;String&gt; args) {\n  var lista = [\"lua\", \"dart\", \"js\", \"java\", \"python\"];\n\n  lista.forEach((lenguaje) {\n    //funcion an\u00f3nima\n    print(\"Es un lenguaje de programaci\u00f3n $lenguaje\");\n    print(\"=========================================\");\n  });\n\n  //funcion flecha\n  lista.forEach((e) =&gt; print(\"Es un lenguaje de programaci\u00f3n $e\"));\n}\n</code></pre>"},{"location":"dart/15.asincronismo/#future","title":"Future","text":"<p>El objeto <code>Future</code> es para indicar que lo que se esta devolviendo es una acci\u00f3n as\u00edncrona, es decir, que no esta devolviendo el resultado, esta devolviendo un <code>Future</code> y cuando termine la tarea, ahora si tendremos el objeto deseado.</p> <p>Para obtener el resultado del <code>Future</code> tenemos dos opciones:</p> <ul> <li>then-catch</li> <li>async-await</li> </ul>"},{"location":"dart/15.asincronismo/#then-catch","title":"then-catch","text":"<p>Cuando recibimos como objeto un <code>Future</code> la forma de obtener ese valor es utilizando su m\u00e9todo <code>then</code>, el cual recibe un callback para retomar ese valor y realizar la siguiente acci\u00f3n.</p> <pre><code>import \"dart:math\";\n\nFuture&lt;int&gt; numberUnknown() {\n  int time = Random().nextInt(5) + 1;\n  print(\"Time to wait: $time\");\n  return Future.delayed(Duration(seconds: time), () =&gt; Random().nextInt(100));\n}\n\nvoid main(List&lt;String&gt; args) {\n  numberUnknown().then((value) {\n    print(\"El valor recibido es: $value\");\n  });\n}\n</code></pre>"},{"location":"dart/15.asincronismo/#manejo-de-error-catcherror","title":"Manejo de error <code>catchError</code>","text":"<p>Para esto tenemos una funcion llamada <code>catchError()</code> la cual recibe un par\u00e1metro de error si en el m\u00e9todo <code>then</code> fallo.</p> <pre><code>import \"dart:math\";\n\nFuture&lt;int&gt; numberUnknown() {\n  int time = Random().nextInt(5) + 1;\n  print(\"Time to wait: $time\");\n  return Future.delayed(Duration(seconds: time), () =&gt; Random().nextInt(100));\n}\n\nvoid main(List&lt;String&gt; args) {\n  numberUnknown().then((value) {\n    print(value);\n  }).catchError((e) {\n    print(\"The error was: $e\");\n  });\n}\n</code></pre>"},{"location":"dart/15.asincronismo/#async-await","title":"async-await","text":"<p>La segunda opci\u00f3n que es mas elegante y se prefiere utilizar es con las palabras reservadas <code>async</code> con <code>await</code>.</p> <p>Note</p> <p>Para poder usar <code>await</code> dentro de una funcion debe ser <code>async</code>.</p> <p>La forma de utilizar <code>await</code> es coloc\u00e1ndole a la funcion que es as\u00edncrona y con esto ya no se necesita usar su m\u00e9todo <code>then</code>. Y donde se realizar\u00eda el <code>then</code>, se antepone <code>await</code> y recibimos el valor como si fuera c\u00f3digo s\u00edncrono.</p> <p><pre><code>void nameFunction() async{\n    int value = await functionAsync();\n}\n</code></pre> Realizamos el c\u00f3digo anterior cambiando el m\u00e9todo <code>then</code> por <code>async-await</code></p> <pre><code>import \"dart:math\";\n\nFuture&lt;int&gt; numberUnknown() {\n  int time = Random().nextInt(5) + 1;\n  print(\"Time to wait: $time\");\n  return Future.delayed(Duration(seconds: time), () =&gt; Random().nextInt(100));\n}\n\nvoid main(List&lt;String&gt; args) async {\n  int numero = await numberUnknown();\n  print(\"El valor recibido es: $numero\");\n}\n</code></pre>"},{"location":"dart/15.asincronismo/#manejo-de-error-try-catch","title":"Manejo de error <code>try-catch</code>","text":"<p>Con <code>async-await</code> se trata con un bloque <code>try-catch</code>, dado que se vuelve un estilo de c\u00f3digo s\u00edncrono.</p> <pre><code>import \"dart:math\";\n\nFuture&lt;int&gt; numberUnknown() {\n  int time = Random().nextInt(5) + 1;\n  print(\"Time to wait: $time\");\n  return Future.delayed(Duration(seconds: time), () =&gt; Random().nextInt(100));\n}\n\nvoid main(List&lt;String&gt; args) async {\n  try {\n    int numero = await numberUnknown();\n    print(\"El valor recibido es: $numero\");\n  } catch (e) {\n    print(\"El error fue: $e\");\n  }\n}\n</code></pre>"},{"location":"dart/20.mini_proyectos/","title":"Mini proyectos","text":""},{"location":"dart/20.mini_proyectos/#generador-de-contrasena-segura","title":"Generador de contrase\u00f1a segura","text":"<p>Genera contrase\u00f1as con todos letras manicuras y may\u00fasculas, s\u00edmbolos y n\u00fameros. Solicit\u00e1ndole al usuario cuantos caracteres debe contener la contrase\u00f1a.</p> <pre><code>import 'dart:convert';\nimport 'dart:math';\nimport 'dart:io';\n\nvoid main(List&lt;String&gt; args) {\n  String letterLower = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\";\n  String letterUpper = letterLower.toUpperCase();\n  String numbers = \"0123456789\";\n  String symbols = \"\\\";!#\\$%&amp;/()=*][_:;-.,}{+\u00bf\\'}]\";\n\n  int passwordLength = 8;\n  String password = \"\";\n\n  print(\"Cual sera el largo de la contrase\u00f1a?\")  ;\n  passwordLength = int.parse(stdin.readLineSync(encoding: utf8)!);\n\n  while(password.length &lt; passwordLength){\n    password += letterLower[Random().nextInt(letterLower.length-1)];\n    password += letterUpper[Random().nextInt(letterUpper.length-1)];\n    password += numbers[Random().nextInt(numbers.length-1)];\n    password += symbols[Random().nextInt(symbols.length-1)];\n  }\n\n  print(\"Tu nueva super contrase\u00f1a SEGURA ES: $password\");\n}\n</code></pre>"},{"location":"dart/20.mini_proyectos/#reto","title":"Reto","text":"<ul> <li>Preguntar por cada tipo s\u00edmbolo, para ser incluido (s\u00edmbolos, letras may\u00fascula o min\u00fascula, n\u00fameros)</li> <li>debe dar el largo de contrase\u00f1a correcto, dato quiero una contrase\u00f1a de 3, sean 3 caracteres, etc.</li> </ul>"},{"location":"dart/20.mini_proyectos/#ordenador-de-documentos","title":"Ordenador de documentos","text":"<p>Aplicaci\u00f3n de terminal o cli, que se le da una direcci\u00f3n de una carpeta de nuestro sistema, analizando las extensiones que le hemos dado, creando las carpetas necesarias, moviendo los archivos con la extension indicada a la carpeta correspondiente.</p> <p>Archivo de las funciones generales</p> read_files.dart<pre><code>import 'dart:io';\n\nconst extensionWord = &lt;String&gt;[\".doc\", \".docx\"];\nconst extensionPDF = &lt;String&gt;[\".pdf\"];\nconst extensionExe = &lt;String&gt;[\".exe\", \".bat\"];\nconst extensionImages = &lt;String&gt;[\".jpeg\", \".jpg\", \".png\", \".gif\"];\nconst extensionCompress = &lt;String&gt;[\".zip\", \".rar\", \".7zip\", \".tar\", \".tar.gz\"];\nconst folders = &lt;String&gt;[\"Word\",\"Imagenes\",\"Comprimidos\",\"pdf\",\"ejecutables\",\"Otros\"];\n\nMap&lt;String, List&lt;String&gt;&gt; extensionMap = {\n  \"Word\":extensionWord,\n  \"pdf\": extensionPDF,\n  \"ejecutables\": extensionExe,\n  \"Imagenes\":extensionImages,\n  \"Comprimidos\": extensionCompress\n};\n\n/**\n * leer los archivos de una carpeta y/o sub carpetas\n */\nList&lt;String&gt; readFiles(String pathDir, [bool recursive = false]) {\n  var paths = &lt;String&gt;[];\n  var dir = Directory(pathDir);\n  var files = dir.listSync(followLinks: false, recursive: recursive);\n\n  for(final file in files){\n    paths.add(file.path);\n  }\n\n return paths;\n}\n\nbool createFolders(String pathDir){\n  for (final folder in folders){\n    Directory(\"$pathDir${Platform.pathSeparator}$folder\").createSync();\n  }\n    return true;\n}\n\nbool moveFile(String pathBase, String pathNewDir){\n\n    String name_file = pathBase.split(Platform.pathSeparator).last;\n\n    print(\"$pathBase -&gt; $pathNewDir${Platform.pathSeparator}$name_file\");\n    File(pathBase).rename(\"$pathNewDir${Platform.pathSeparator}$name_file\");\n\n    return true;\n}\n\nString getNameFolder(String path){\n    String folder = \"Otros\";\n    String name_file = path.split(Platform.pathSeparator).last;\n\n    for(final key in extensionMap.keys){\n      var listExt = extensionMap[key];\n      for(final ext in listExt!){\n        if(name_file.endsWith(ext)){\n          return key;\n        }\n      }\n    }\n\n    return folder;\n\n}\n\n//main es para pruebas\nvoid main(List&lt;String&gt; args) {\n  String pathDir = \"C:\\\\Users\\\\usuario\\\\Documents\\\\prueba\";\n  final paths = readFiles(pathDir);\n  createFolders(pathDir);\n\n  for(final path in paths){\n    moveFile(\n      path,\n      pathDir+Platform.pathSeparator+ getNameFolder(path));\n  }\n\n}\n</code></pre> <p>Archivo main</p> main.dart<pre><code>import 'dart:io';\n\nimport 'read_files.dart'; // importamos la librer\u00eda de funciones\n\n/**\n * Punto de entrada de la aplicaci\u00f3n\n */\nvoid main(List&lt;String&gt; args) {\n  String pathDir = args[0];\n\n  final paths = readFiles(pathDir);\n  createFolders(pathDir);\n  try {\n    for (final path in paths) {\n      moveFile(path, pathDir + Platform.pathSeparator + getNameFolder(path));\n    }\n  } catch (e) {}\n}\n</code></pre> <p>Forma de uso</p> <pre><code>dart main.dart \"C:\\\\Users\\\\usuario\\\\Documents\\\\prueba\" # sin compilar\n\n./ordenador \"C:\\\\Users\\\\usuario\\\\Documents\\\\prueba\"  # con el binario compilado\n</code></pre>"},{"location":"dart/20.mini_proyectos/#reto_1","title":"Reto","text":"<ul> <li>Que verifique si es un archivo o carpeta, y que ignore las carpetas y solo mueva los archivos</li> <li>Leer un archivo de configuraci\u00f3n de los formatos y a la carpeta que se deben mover</li> <li>Verificar si la carpeta ya existe, y evite volver a crearla</li> <li>Verificar que la ruta que de el usuario sea valida</li> <li>En caso que de mal alg\u00fan par\u00e1metro, no de par\u00e1metros o se exceda, mandar el mensaje de ayuda de como funciona la aplicaci\u00f3n</li> </ul>"},{"location":"dart/20.mini_proyectos/#descargar","title":"Descargar","text":"<ul> <li>Version Windows x64 descargar</li> <li>Version Linux x64 descargar</li> </ul>"},{"location":"dart/20.mini_proyectos/#verificacion-de-cambio-de-cantidad-de-archivos-y-carpetas-dado-un-directorio","title":"Verificaci\u00f3n de cambio de cantidad de archivos y carpetas, dado un directorio","text":"<p>En este proyecto queremos generar un archivo snapshot con el listado de todo el contenido de una carpeta o carpetas, todo contenido en un archivo de configuraci\u00f3n. Este archivo de configuraci\u00f3n contiene las rutas de las carpetas a analizar. Se generara un archivo con el listado de todos los archivos de esa carpeta, que se utilizara despu\u00e9s para hacer la companion, para saber si ha existido alg\u00fan cambio dentro de ella</p> read_config.dart<pre><code>// archivo de configuraci\u00f3n\n//  - leer el archivo (function)\nimport 'dart:convert';\nimport 'dart:io';\n\n/// This function read a json file with the config\nFuture&lt;Map&lt;String, dynamic&gt;&gt; readFileConfig(String path) async {\n  File file = File(path);\n  String content = await file.readAsString();\n  var json = jsonDecode(content);\n  return json;\n}\n\n/// This function write json file with the new config\nFuture&lt;void&gt; writeFileConfig(\n    String pathFile, Map&lt;String, dynamic&gt; config) async {\n  File file = File(pathFile);\n  JsonEncoder encoder = JsonEncoder.withIndent(\"\\t\");\n  String json = encoder.convert(config);\n  await file.writeAsString(json);\n}\n</code></pre> lib/folder.dar<pre><code>// Leer el contenido de una carpeta\n// generar el archivo base y estar leyendo la misma carpeta\n// para comparar\n\nimport 'dart:io';\n\nimport 'package:cleaner/read_config.dart';\n\nclass Folder {\n  final String _pathFolder;\n  String _pathSnapshot = \"\";\n  late final String _pathJSONConfig;\n\n  Folder(\n      {required String pathDir,\n      String pathSnapshot = \"\",\n      required String pathJsonConfig})\n      : _pathFolder = pathDir,\n        _pathSnapshot = pathSnapshot,\n        _pathJSONConfig = pathJsonConfig;\n\n  // get list from files and folders from the dir\n  Future&lt;List&lt;FileSystemEntity&gt;&gt; _getContentDir() async {\n    Directory dir = Directory(_pathFolder);\n    return await dir.list(recursive: true).toList();\n  }\n\n  /// Creates the file that will contain the list of files and folders,\n  /// only gives it the title of the columns\n  Future&lt;String&gt; _createFileSnapshot([String path = \"\"]) async {\n    if (path.isEmpty) path = Directory.current.path;\n    String time =\n        \"${DateTime.now().day}_${DateTime.now().month}_${DateTime.now().year}_${DateTime.now().hour}_${DateTime.now().minute}\";\n    String fullPath =\n        \"$path${Platform.pathSeparator}snapshot_${_nameFileCSV()}_$time.csv\";\n    print(\"Snapshot created at: $fullPath\");\n    File snapshot = File(fullPath);\n    await snapshot.create();\n    await snapshot.writeAsString(\"path, tipo\\n\");\n    _pathSnapshot = snapshot.path;\n    return snapshot.path;\n  }\n\n  /// Save the content from folder\n  Future&lt;void&gt; _saveContent(List&lt;FileSystemEntity&gt; listFiles) async {\n    File fileSnapshot = File(_pathSnapshot);\n\n    String row = \"\";\n    for (final element in listFiles) {\n      if (element is File) {\n        //print(\"es un ARCHIVO:${element.path}\");\n        row += \"\\\"${element.path}\\\",file\\n\";\n      } else if (element is Directory) {\n        //print(\"es una CARPETA:${element.path}\");\n        row += \"\\\"${element.path}\\\",folder\\n\";\n      }\n      fileSnapshot.writeAsString(row, mode: FileMode.append);\n    }\n  }\n\n  /// Read data from file snapshot.csv and return a list with content\n  Future&lt;List&lt;String&gt;&gt; _readSnapshot([String path = \"\"]) async {\n    if (path.isNotEmpty) _pathSnapshot = path;\n\n    final File snapshotBase = File(_pathSnapshot);\n    List&lt;String&gt; files = [];\n    for (final row in await snapshotBase.readAsLines()) {\n      String path = row.split(\",\")[0];\n      if (path == \"path\") continue;\n      files.add(path);\n    }\n    return files;\n  }\n\n  /// compare the length from snapshot file to list file now\n  Future&lt;bool&gt; compareSnapshot([String pathSnapshotBase = \"\"]) async {\n    if (pathSnapshotBase.isNotEmpty) _pathSnapshot = pathSnapshotBase;\n\n    List&lt;String&gt; snapshotBase = await _readSnapshot(_pathSnapshot);\n    List&lt;FileSystemEntity&gt; snapshotNow = await _getContentDir();\n\n    return snapshotBase.length == snapshotNow.length;\n  }\n\n  // get the name from folder\n  String _nameFileCSV() {\n    print(\"El path completo $_pathFolder\");\n    String name = _pathFolder;\n    if (_pathFolder.endsWith(Platform.pathSeparator)) {\n      name = _pathFolder.substring(0, _pathFolder.length - 2);\n    }\n\n    name = name.substring(name.lastIndexOf(Platform.pathSeparator) + 1);\n    print(\"nombre corto: $name\");\n    return name;\n  }\n\n  // get snapshot from file or create a new\n  Future&lt;List&lt;String&gt;&gt; getSnapshot([int position = -1]) async {\n    Map&lt;String, dynamic&gt; json = await readFileConfig(_pathJSONConfig);\n\n    if (_pathSnapshot.isNotEmpty &amp;&amp; position != -1) {\n      _pathSnapshot = List&lt;String&gt;.from(json[\"snapshot\"] ?? [])[position];\n    } else {\n      await _createFileSnapshot();\n      await _saveContent(await _getContentDir());\n      List&lt;String&gt; snapshots = List&lt;String&gt;.from(json[\"snapshot\"] ?? []);\n      snapshots.add(_pathSnapshot);\n      json[\"snapshot\"] = snapshots;\n      await writeFileConfig(_pathJSONConfig, json);\n    }\n\n    return await _readSnapshot(_pathSnapshot);\n  }\n}\n</code></pre> bin/main.dart<pre><code>import 'dart:io';\n\nimport 'package:cleaner/folder.dart';\nimport 'package:cleaner/read_config.dart';\n\n// ignore: constant_identifier_names\nconst HELP = \"\"\"\ncleaner &lt;file_config.json&gt;\n\ncleaner cleaner.config.json\n\"\"\";\n\nvoid main(List&lt;String&gt; args) async {\n  try {\n    if (args.length == 1 &amp;&amp; args[0].isNotEmpty &amp;&amp; File(args[0]).existsSync()) {\n      String pathConfig = args[0];\n\n      Map&lt;String, dynamic&gt; jsonConfig = await readFileConfig(pathConfig);\n      List&lt;String&gt; pathDirs = List&lt;String&gt;.from(jsonConfig[\"directories\"]);\n      List&lt;String&gt; pathSnapshots =\n          List&lt;String&gt;.from(jsonConfig[\"snapshot\"] ?? &lt;String&gt;[]);\n\n      for (int i = 0; i &lt; pathDirs.length; i++) {\n        String snapShotPath = pathSnapshots.isNotEmpty ? pathSnapshots[i] : \"\";\n        Folder folder = Folder(\n            pathDir: pathDirs[i],\n            pathJsonConfig: pathConfig,\n            pathSnapshot: snapShotPath);\n\n        await folder.getSnapshot(i);\n        bool compare = await folder.compareSnapshot();\n        print(compare ? \"OK\" : \"CAMBIO\");\n      }\n    } else {\n      print(\"Error\");\n      print(HELP);\n    }\n  } catch (e) {\n    print(e);\n    print(\"Error\");\n    print(HELP);\n  }\n}\n</code></pre> <p>Archivo de configuraci\u00f3n que lee la aplicaci\u00f3n</p> <p>Nota: La secci\u00f3n de <code>exclude</code> no esta implementado</p> cleaner.config.json<pre><code>{\n \"directories\": [\n  \"path absolute 1\",\n  \"path absolute 1\"\n ],\n \"exclude\": {\n  \"directories\": [],\n  \"ext\": []\n }\n}\n</code></pre>"},{"location":"dart/20.mini_proyectos/#reto_2","title":"Reto","text":"<ul> <li>Implementar la secci\u00f3n de <code>exclude</code>, para que evite agregar al snapshot ciertas carpetas y/o extensiones de archivos que se especifiquen en el archivo de configuraci\u00f3n.</li> <li>Eliminar las carpetas y archivos nuevos que no estaban en el snapshot original</li> <li>Implementar una base de datos <code>SQLite</code> para optimizar la busque y comparaci\u00f3n de archivos</li> <li>Generar y guardar su hash, para hacer mas eficiente la b\u00fasqueda</li> <li>Generar un archivo con el listado de archivos y carpetas que no estaban en el snapshot original</li> <li>Todo lo que se te venga a la mente y te pueda ser util</li> </ul> <p>Descargar el compilado para Linux arch64</p>"}]}